(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[8],{

/***/ "../text-editor/dist/esm-es5/active-router-9e2533ec.js":
/*!*************************************************************!*\
  !*** ../text-editor/dist/esm-es5/active-router-9e2533ec.js ***!
  \*************************************************************/
/*! exports provided: A */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"A\", function() { return ActiveRouter; });\n/* harmony import */ var _index_7f90bc21_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-7f90bc21.js */ \"../text-editor/dist/esm-es5/index-7f90bc21.js\");\nvar __spreadArrays = (undefined && undefined.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\n\nvar createProviderConsumer = function (defaultState, consumerRender) {\n    var listeners = new Map();\n    var currentState = defaultState;\n    var updateListener = function (fields, instance) {\n        if (Array.isArray(fields)) {\n            __spreadArrays(fields).forEach(function (fieldName) {\n                instance[fieldName] = currentState[fieldName];\n            });\n        }\n        else {\n            instance[fields] = Object.assign({}, currentState);\n        }\n    };\n    var subscribe = function (instance, propList) {\n        if (!listeners.has(instance)) {\n            listeners.set(instance, propList);\n            updateListener(propList, instance);\n        }\n        return function () {\n            if (listeners.has(instance)) {\n                listeners.delete(instance);\n            }\n        };\n    };\n    var Provider = function (_a, children) {\n        var state = _a.state;\n        currentState = state;\n        listeners.forEach(updateListener);\n        return children;\n    };\n    var Consumer = function (props, children) {\n        // The casting on subscribe is to allow for crossover through the stencil compiler\n        // In the future we should allow for generics in components.\n        return consumerRender(subscribe, children[0]);\n    };\n    var injectProps = function (Cstr, fieldList) {\n        var CstrPrototype = Cstr.prototype;\n        var cstrConnectedCallback = CstrPrototype.connectedCallback;\n        var cstrDisconnectedCallback = CstrPrototype.disconnectedCallback;\n        CstrPrototype.connectedCallback = function () {\n            subscribe(this, fieldList);\n            if (cstrConnectedCallback) {\n                return cstrConnectedCallback.call(this);\n            }\n        };\n        CstrPrototype.disconnectedCallback = function () {\n            listeners.delete(this);\n            if (cstrDisconnectedCallback) {\n                cstrDisconnectedCallback.call(this);\n            }\n        };\n    };\n    return {\n        Provider: Provider,\n        Consumer: Consumer,\n        injectProps: injectProps\n    };\n};\nvar ActiveRouter = createProviderConsumer({\n    historyType: 'browser',\n    location: {\n        pathname: '',\n        query: {},\n        key: ''\n    },\n    titleSuffix: '',\n    root: '/',\n    routeViewsUpdated: function () { }\n}, function (subscribe, child) { return (Object(_index_7f90bc21_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(\"context-consumer\", { subscribe: subscribe, renderer: child })); });\n\n\n\n//# sourceURL=webpack:///../text-editor/dist/esm-es5/active-router-9e2533ec.js?");

/***/ }),

/***/ "../text-editor/dist/esm-es5/dom-utils-e7b9691d.js":
/*!*********************************************************!*\
  !*** ../text-editor/dist/esm-es5/dom-utils-e7b9691d.js ***!
  \*********************************************************/
/*! exports provided: a, b, c, d, g, i, s */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return supportsHistory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return supportsPopStateOnHashChange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return isExtraneousPopstateEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return supportsGoWithoutReloadUsingHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return getConfirmation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return isModifiedEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"s\", function() { return storageAvailable; });\nvar getConfirmation = function (win, message, callback) { return (callback(win.confirm(message))); };\nvar isModifiedEvent = function (ev) { return (ev.metaKey || ev.altKey || ev.ctrlKey || ev.shiftKey); };\n/**\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\n *\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\n */\nvar supportsHistory = function (win) {\n    var ua = win.navigator.userAgent;\n    if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\n        ua.indexOf('Mobile Safari') !== -1 &&\n        ua.indexOf('Chrome') === -1 &&\n        ua.indexOf('Windows Phone') === -1) {\n        return false;\n    }\n    return win.history && 'pushState' in win.history;\n};\n/**\n * Returns true if browser fires popstate on hash change.\n * IE10 and IE11 do not.\n */\nvar supportsPopStateOnHashChange = function (nav) { return (nav.userAgent.indexOf('Trident') === -1); };\n/**\n * Returns false if using go(n) with hash history causes a full page reload.\n */\nvar supportsGoWithoutReloadUsingHash = function (nav) { return (nav.userAgent.indexOf('Firefox') === -1); };\nvar isExtraneousPopstateEvent = function (nav, event) { return (event.state === undefined &&\n    nav.userAgent.indexOf('CriOS') === -1); };\nvar storageAvailable = function (win, type) {\n    var storage = win[type];\n    var x = '__storage_test__';\n    try {\n        storage.setItem(x, x);\n        storage.removeItem(x);\n        return true;\n    }\n    catch (e) {\n        return e instanceof DOMException && (\n        // everything except Firefox\n        e.code === 22 ||\n            // Firefox\n            e.code === 1014 ||\n            // test name field too, because code might not be present\n            // everything except Firefox\n            e.name === 'QuotaExceededError' ||\n            // Firefox\n            e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\n            // acknowledge QuotaExceededError only if there's something already stored\n            storage.length !== 0;\n    }\n};\n\n\n\n//# sourceURL=webpack:///../text-editor/dist/esm-es5/dom-utils-e7b9691d.js?");

/***/ }),

/***/ "../text-editor/dist/esm-es5/location-utils-aaafd5ed.js":
/*!**************************************************************!*\
  !*** ../text-editor/dist/esm-es5/location-utils-aaafd5ed.js ***!
  \**************************************************************/
/*! exports provided: a, b, c, d, e, f, h, l, s, v */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return addLeadingSlash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return createKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return createLocation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return stripBasename; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return createPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return stripLeadingSlash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return hasBasename; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"l\", function() { return locationsAreEqual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"s\", function() { return stripTrailingSlash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"v\", function() { return valueEqual; });\nvar hasBasename = function (path, prefix) {\n    return (new RegExp('^' + prefix + '(\\\\/|\\\\?|#|$)', 'i')).test(path);\n};\nvar stripBasename = function (path, prefix) {\n    return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\n};\nvar stripTrailingSlash = function (path) {\n    return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;\n};\nvar addLeadingSlash = function (path) {\n    return path.charAt(0) === '/' ? path : '/' + path;\n};\nvar stripLeadingSlash = function (path) {\n    return path.charAt(0) === '/' ? path.substr(1) : path;\n};\nvar parsePath = function (path) {\n    var pathname = path || '/';\n    var search = '';\n    var hash = '';\n    var hashIndex = pathname.indexOf('#');\n    if (hashIndex !== -1) {\n        hash = pathname.substr(hashIndex);\n        pathname = pathname.substr(0, hashIndex);\n    }\n    var searchIndex = pathname.indexOf('?');\n    if (searchIndex !== -1) {\n        search = pathname.substr(searchIndex);\n        pathname = pathname.substr(0, searchIndex);\n    }\n    return {\n        pathname: pathname,\n        search: search === '?' ? '' : search,\n        hash: hash === '#' ? '' : hash,\n        query: {},\n        key: ''\n    };\n};\nvar createPath = function (location) {\n    var pathname = location.pathname, search = location.search, hash = location.hash;\n    var path = pathname || '/';\n    if (search && search !== '?') {\n        path += (search.charAt(0) === '?' ? search : \"?\" + search);\n    }\n    if (hash && hash !== '#') {\n        path += (hash.charAt(0) === '#' ? hash : \"#\" + hash);\n    }\n    return path;\n};\nvar parseQueryString = function (query) {\n    if (!query) {\n        return {};\n    }\n    return (/^[?#]/.test(query) ? query.slice(1) : query)\n        .split('&')\n        .reduce(function (params, param) {\n        var _a = param.split('='), key = _a[0], value = _a[1];\n        params[key] = value ? decodeURIComponent(value.replace(/\\+/g, ' ')) : '';\n        return params;\n    }, {});\n};\nvar isAbsolute = function (pathname) {\n    return pathname.charAt(0) === '/';\n};\nvar createKey = function (keyLength) {\n    return Math.random().toString(36).substr(2, keyLength);\n};\n// About 1.5x faster than the two-arg version of Array#splice()\nvar spliceOne = function (list, index) {\n    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\n        list[i] = list[k];\n    }\n    list.pop();\n};\n// This implementation is based heavily on node's url.parse\nvar resolvePathname = function (to, from) {\n    if (from === void 0) { from = ''; }\n    var fromParts = from && from.split('/') || [];\n    var hasTrailingSlash;\n    var up = 0;\n    var toParts = to && to.split('/') || [];\n    var isToAbs = to && isAbsolute(to);\n    var isFromAbs = from && isAbsolute(from);\n    var mustEndAbs = isToAbs || isFromAbs;\n    if (to && isAbsolute(to)) {\n        // to is absolute\n        fromParts = toParts;\n    }\n    else if (toParts.length) {\n        // to is relative, drop the filename\n        fromParts.pop();\n        fromParts = fromParts.concat(toParts);\n    }\n    if (!fromParts.length) {\n        return '/';\n    }\n    if (fromParts.length) {\n        var last = fromParts[fromParts.length - 1];\n        hasTrailingSlash = (last === '.' || last === '..' || last === '');\n    }\n    else {\n        hasTrailingSlash = false;\n    }\n    for (var i = fromParts.length; i >= 0; i--) {\n        var part = fromParts[i];\n        if (part === '.') {\n            spliceOne(fromParts, i);\n        }\n        else if (part === '..') {\n            spliceOne(fromParts, i);\n            up++;\n        }\n        else if (up) {\n            spliceOne(fromParts, i);\n            up--;\n        }\n    }\n    if (!mustEndAbs) {\n        for (; up--; up) {\n            fromParts.unshift('..');\n        }\n    }\n    if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) {\n        fromParts.unshift('');\n    }\n    var result = fromParts.join('/');\n    if (hasTrailingSlash && result.substr(-1) !== '/') {\n        result += '/';\n    }\n    return result;\n};\nvar valueEqual = function (a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a == null || b == null) {\n        return false;\n    }\n    if (Array.isArray(a)) {\n        return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {\n            return valueEqual(item, b[index]);\n        });\n    }\n    var aType = typeof a;\n    var bType = typeof b;\n    if (aType !== bType) {\n        return false;\n    }\n    if (aType === 'object') {\n        var aValue = a.valueOf();\n        var bValue = b.valueOf();\n        if (aValue !== a || bValue !== b) {\n            return valueEqual(aValue, bValue);\n        }\n        var aKeys = Object.keys(a);\n        var bKeys = Object.keys(b);\n        if (aKeys.length !== bKeys.length) {\n            return false;\n        }\n        return aKeys.every(function (key) {\n            return valueEqual(a[key], b[key]);\n        });\n    }\n    return false;\n};\nvar locationsAreEqual = function (a, b) {\n    return a.pathname === b.pathname &&\n        a.search === b.search &&\n        a.hash === b.hash &&\n        a.key === b.key &&\n        valueEqual(a.state, b.state);\n};\nvar createLocation = function (path, state, key, currentLocation) {\n    var location;\n    if (typeof path === 'string') {\n        // Two-arg form: push(path, state)\n        location = parsePath(path);\n        if (state !== undefined) {\n            location.state = state;\n        }\n    }\n    else {\n        // One-arg form: push(location)\n        location = Object.assign({ pathname: '' }, path);\n        if (location.search && location.search.charAt(0) !== '?') {\n            location.search = '?' + location.search;\n        }\n        if (location.hash && location.hash.charAt(0) !== '#') {\n            location.hash = '#' + location.hash;\n        }\n        if (state !== undefined && location.state === undefined) {\n            location.state = state;\n        }\n    }\n    try {\n        location.pathname = decodeURI(location.pathname);\n    }\n    catch (e) {\n        if (e instanceof URIError) {\n            throw new URIError('Pathname \"' + location.pathname + '\" could not be decoded. ' +\n                'This is likely caused by an invalid percent-encoding.');\n        }\n        else {\n            throw e;\n        }\n    }\n    location.key = key;\n    if (currentLocation) {\n        // Resolve incomplete/relative pathname relative to current location.\n        if (!location.pathname) {\n            location.pathname = currentLocation.pathname;\n        }\n        else if (location.pathname.charAt(0) !== '/') {\n            location.pathname = resolvePathname(location.pathname, currentLocation.pathname);\n        }\n    }\n    else {\n        // When there is no prior location and pathname is empty, set it to /\n        if (!location.pathname) {\n            location.pathname = '/';\n        }\n    }\n    location.query = parseQueryString(location.search || '');\n    return location;\n};\n\n\n\n//# sourceURL=webpack:///../text-editor/dist/esm-es5/location-utils-aaafd5ed.js?");

/***/ }),

/***/ "../text-editor/dist/esm-es5/stencil-router.entry.js":
/*!***********************************************************!*\
  !*** ../text-editor/dist/esm-es5/stencil-router.entry.js ***!
  \***********************************************************/
/*! exports provided: stencil_router */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stencil_router\", function() { return Router; });\n/* harmony import */ var _index_7f90bc21_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-7f90bc21.js */ \"../text-editor/dist/esm-es5/index-7f90bc21.js\");\n/* harmony import */ var _active_router_9e2533ec_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./active-router-9e2533ec.js */ \"../text-editor/dist/esm-es5/active-router-9e2533ec.js\");\n/* harmony import */ var _location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./location-utils-aaafd5ed.js */ \"../text-editor/dist/esm-es5/location-utils-aaafd5ed.js\");\n/* harmony import */ var _dom_utils_e7b9691d_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dom-utils-e7b9691d.js */ \"../text-editor/dist/esm-es5/dom-utils-e7b9691d.js\");\n\n\n\n\nvar warning = function (value) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    if (!value) {\n        console.warn.apply(console, args);\n    }\n};\n// Adapted from the https://github.com/ReactTraining/history and converted to TypeScript\nvar createTransitionManager = function () {\n    var prompt;\n    var listeners = [];\n    var setPrompt = function (nextPrompt) {\n        warning(prompt == null, 'A history supports only one prompt at a time');\n        prompt = nextPrompt;\n        return function () {\n            if (prompt === nextPrompt) {\n                prompt = null;\n            }\n        };\n    };\n    var confirmTransitionTo = function (location, action, getUserConfirmation, callback) {\n        // TODO: If another transition starts while we're still confirming\n        // the previous one, we may end up in a weird state. Figure out the\n        // best way to handle this.\n        if (prompt != null) {\n            var result = typeof prompt === 'function' ? prompt(location, action) : prompt;\n            if (typeof result === 'string') {\n                if (typeof getUserConfirmation === 'function') {\n                    getUserConfirmation(result, callback);\n                }\n                else {\n                    warning(false, 'A history needs a getUserConfirmation function in order to use a prompt message');\n                    callback(true);\n                }\n            }\n            else {\n                // Return false from a transition hook to cancel the transition.\n                callback(result !== false);\n            }\n        }\n        else {\n            callback(true);\n        }\n    };\n    var appendListener = function (fn) {\n        var isActive = true;\n        var listener = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            if (isActive) {\n                fn.apply(void 0, args);\n            }\n        };\n        listeners.push(listener);\n        return function () {\n            isActive = false;\n            listeners = listeners.filter(function (item) { return item !== listener; });\n        };\n    };\n    var notifyListeners = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        listeners.forEach(function (listener) { return listener.apply(void 0, args); });\n    };\n    return {\n        setPrompt: setPrompt,\n        confirmTransitionTo: confirmTransitionTo,\n        appendListener: appendListener,\n        notifyListeners: notifyListeners\n    };\n};\nvar createScrollHistory = function (win, applicationScrollKey) {\n    if (applicationScrollKey === void 0) { applicationScrollKey = 'scrollPositions'; }\n    var scrollPositions = new Map();\n    var set = function (key, value) {\n        scrollPositions.set(key, value);\n        if (Object(_dom_utils_e7b9691d_js__WEBPACK_IMPORTED_MODULE_3__[\"s\"])(win, 'sessionStorage')) {\n            var arrayData_1 = [];\n            scrollPositions.forEach(function (value, key) {\n                arrayData_1.push([key, value]);\n            });\n            win.sessionStorage.setItem('scrollPositions', JSON.stringify(arrayData_1));\n        }\n    };\n    var get = function (key) {\n        return scrollPositions.get(key);\n    };\n    var has = function (key) {\n        return scrollPositions.has(key);\n    };\n    var capture = function (key) {\n        set(key, [win.scrollX, win.scrollY]);\n    };\n    if (Object(_dom_utils_e7b9691d_js__WEBPACK_IMPORTED_MODULE_3__[\"s\"])(win, 'sessionStorage')) {\n        var scrollData = win.sessionStorage.getItem(applicationScrollKey);\n        scrollPositions = scrollData ?\n            new Map(JSON.parse(scrollData)) :\n            scrollPositions;\n    }\n    if ('scrollRestoration' in win.history) {\n        history.scrollRestoration = 'manual';\n    }\n    return {\n        set: set,\n        get: get,\n        has: has,\n        capture: capture\n    };\n};\n// Adapted from the https://github.com/ReactTraining/history and converted to TypeScript\nvar PopStateEvent = 'popstate';\nvar HashChangeEvent = 'hashchange';\n/**\n * Creates a history object that uses the HTML5 history API including\n * pushState, replaceState, and the popstate event.\n */\nvar createBrowserHistory = function (win, props) {\n    if (props === void 0) { props = {}; }\n    var forceNextPop = false;\n    var globalHistory = win.history;\n    var globalLocation = win.location;\n    var globalNavigator = win.navigator;\n    var canUseHistory = Object(_dom_utils_e7b9691d_js__WEBPACK_IMPORTED_MODULE_3__[\"a\"])(win);\n    var needsHashChangeListener = !Object(_dom_utils_e7b9691d_js__WEBPACK_IMPORTED_MODULE_3__[\"b\"])(globalNavigator);\n    var scrollHistory = createScrollHistory(win);\n    var forceRefresh = (props.forceRefresh != null) ? props.forceRefresh : false;\n    var getUserConfirmation = (props.getUserConfirmation != null) ? props.getUserConfirmation : _dom_utils_e7b9691d_js__WEBPACK_IMPORTED_MODULE_3__[\"g\"];\n    var keyLength = (props.keyLength != null) ? props.keyLength : 6;\n    var basename = props.basename ? Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"s\"])(Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"a\"])(props.basename)) : '';\n    var getHistoryState = function () {\n        try {\n            return win.history.state || {};\n        }\n        catch (e) {\n            // IE 11 sometimes throws when accessing window.history.state\n            // See https://github.com/ReactTraining/history/pull/289\n            return {};\n        }\n    };\n    var getDOMLocation = function (historyState) {\n        historyState = historyState || {};\n        var key = historyState.key, state = historyState.state;\n        var pathname = globalLocation.pathname, search = globalLocation.search, hash = globalLocation.hash;\n        var path = pathname + search + hash;\n        warning((!basename || Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"h\"])(path, basename)), 'You are attempting to use a basename on a page whose URL path does not begin ' +\n            'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\n        if (basename) {\n            path = Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"d\"])(path, basename);\n        }\n        return Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"c\"])(path, state, key || Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"b\"])(keyLength));\n    };\n    var transitionManager = createTransitionManager();\n    var setState = function (nextState) {\n        // Capture location for the view before changing history.\n        scrollHistory.capture(history.location.key);\n        Object.assign(history, nextState);\n        // Set scroll position based on its previous storage value\n        history.location.scrollPosition = scrollHistory.get(history.location.key);\n        history.length = globalHistory.length;\n        transitionManager.notifyListeners(history.location, history.action);\n    };\n    var handlePopState = function (event) {\n        // Ignore extraneous popstate events in WebKit.\n        if (!Object(_dom_utils_e7b9691d_js__WEBPACK_IMPORTED_MODULE_3__[\"c\"])(globalNavigator, event)) {\n            handlePop(getDOMLocation(event.state));\n        }\n    };\n    var handleHashChange = function () {\n        handlePop(getDOMLocation(getHistoryState()));\n    };\n    var handlePop = function (location) {\n        if (forceNextPop) {\n            forceNextPop = false;\n            setState();\n        }\n        else {\n            var action_1 = 'POP';\n            transitionManager.confirmTransitionTo(location, action_1, getUserConfirmation, function (ok) {\n                if (ok) {\n                    setState({ action: action_1, location: location });\n                }\n                else {\n                    revertPop(location);\n                }\n            });\n        }\n    };\n    var revertPop = function (fromLocation) {\n        var toLocation = history.location;\n        // TODO: We could probably make this more reliable by\n        // keeping a list of keys we've seen in sessionStorage.\n        // Instead, we just default to 0 for keys we don't know.\n        var toIndex = allKeys.indexOf(toLocation.key);\n        var fromIndex = allKeys.indexOf(fromLocation.key);\n        if (toIndex === -1) {\n            toIndex = 0;\n        }\n        if (fromIndex === -1) {\n            fromIndex = 0;\n        }\n        var delta = toIndex - fromIndex;\n        if (delta) {\n            forceNextPop = true;\n            go(delta);\n        }\n    };\n    var initialLocation = getDOMLocation(getHistoryState());\n    var allKeys = [initialLocation.key];\n    var listenerCount = 0;\n    var isBlocked = false;\n    // Public interface\n    var createHref = function (location) {\n        return basename + Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"e\"])(location);\n    };\n    var push = function (path, state) {\n        warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' +\n            'argument is a location-like object that already has state; it is ignored');\n        var action = 'PUSH';\n        var location = Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"c\"])(path, state, Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"b\"])(keyLength), history.location);\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n            if (!ok) {\n                return;\n            }\n            var href = createHref(location);\n            var key = location.key, state = location.state;\n            if (canUseHistory) {\n                globalHistory.pushState({ key: key, state: state }, '', href);\n                if (forceRefresh) {\n                    globalLocation.href = href;\n                }\n                else {\n                    var prevIndex = allKeys.indexOf(history.location.key);\n                    var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n                    nextKeys.push(location.key);\n                    allKeys = nextKeys;\n                    setState({ action: action, location: location });\n                }\n            }\n            else {\n                warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');\n                globalLocation.href = href;\n            }\n        });\n    };\n    var replace = function (path, state) {\n        warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' +\n            'argument is a location-like object that already has state; it is ignored');\n        var action = 'REPLACE';\n        var location = Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"c\"])(path, state, Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"b\"])(keyLength), history.location);\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n            if (!ok) {\n                return;\n            }\n            var href = createHref(location);\n            var key = location.key, state = location.state;\n            if (canUseHistory) {\n                globalHistory.replaceState({ key: key, state: state }, '', href);\n                if (forceRefresh) {\n                    globalLocation.replace(href);\n                }\n                else {\n                    var prevIndex = allKeys.indexOf(history.location.key);\n                    if (prevIndex !== -1) {\n                        allKeys[prevIndex] = location.key;\n                    }\n                    setState({ action: action, location: location });\n                }\n            }\n            else {\n                warning(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');\n                globalLocation.replace(href);\n            }\n        });\n    };\n    var go = function (n) {\n        globalHistory.go(n);\n    };\n    var goBack = function () { return go(-1); };\n    var goForward = function () { return go(1); };\n    var checkDOMListeners = function (delta) {\n        listenerCount += delta;\n        if (listenerCount === 1) {\n            win.addEventListener(PopStateEvent, handlePopState);\n            if (needsHashChangeListener) {\n                win.addEventListener(HashChangeEvent, handleHashChange);\n            }\n        }\n        else if (listenerCount === 0) {\n            win.removeEventListener(PopStateEvent, handlePopState);\n            if (needsHashChangeListener) {\n                win.removeEventListener(HashChangeEvent, handleHashChange);\n            }\n        }\n    };\n    var block = function (prompt) {\n        if (prompt === void 0) { prompt = ''; }\n        var unblock = transitionManager.setPrompt(prompt);\n        if (!isBlocked) {\n            checkDOMListeners(1);\n            isBlocked = true;\n        }\n        return function () {\n            if (isBlocked) {\n                isBlocked = false;\n                checkDOMListeners(-1);\n            }\n            return unblock();\n        };\n    };\n    var listen = function (listener) {\n        var unlisten = transitionManager.appendListener(listener);\n        checkDOMListeners(1);\n        return function () {\n            checkDOMListeners(-1);\n            unlisten();\n        };\n    };\n    var history = {\n        length: globalHistory.length,\n        action: 'POP',\n        location: initialLocation,\n        createHref: createHref,\n        push: push,\n        replace: replace,\n        go: go,\n        goBack: goBack,\n        goForward: goForward,\n        block: block,\n        listen: listen,\n        win: win\n    };\n    return history;\n};\n// Adapted from the https://github.com/ReactTraining/history and converted to TypeScript\nvar HashChangeEvent$1 = 'hashchange';\nvar HashPathCoders = {\n    hashbang: {\n        encodePath: function (path) { return path.charAt(0) === '!' ? path : '!/' + Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"f\"])(path); },\n        decodePath: function (path) { return path.charAt(0) === '!' ? path.substr(1) : path; }\n    },\n    noslash: {\n        encodePath: _location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"f\"],\n        decodePath: _location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"a\"]\n    },\n    slash: {\n        encodePath: _location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"a\"],\n        decodePath: _location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"a\"]\n    }\n};\nvar createHashHistory = function (win, props) {\n    if (props === void 0) { props = {}; }\n    var forceNextPop = false;\n    var ignorePath = null;\n    var listenerCount = 0;\n    var isBlocked = false;\n    var globalLocation = win.location;\n    var globalHistory = win.history;\n    var canGoWithoutReload = Object(_dom_utils_e7b9691d_js__WEBPACK_IMPORTED_MODULE_3__[\"d\"])(win.navigator);\n    var keyLength = (props.keyLength != null) ? props.keyLength : 6;\n    var _a = props.getUserConfirmation, getUserConfirmation = _a === void 0 ? _dom_utils_e7b9691d_js__WEBPACK_IMPORTED_MODULE_3__[\"g\"] : _a, _b = props.hashType, hashType = _b === void 0 ? 'slash' : _b;\n    var basename = props.basename ? Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"s\"])(Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"a\"])(props.basename)) : '';\n    var _c = HashPathCoders[hashType], encodePath = _c.encodePath, decodePath = _c.decodePath;\n    var getHashPath = function () {\n        // We can't use window.location.hash here because it's not\n        // consistent across browsers - Firefox will pre-decode it!\n        var href = globalLocation.href;\n        var hashIndex = href.indexOf('#');\n        return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\n    };\n    var pushHashPath = function (path) { return (globalLocation.hash = path); };\n    var replaceHashPath = function (path) {\n        var hashIndex = globalLocation.href.indexOf('#');\n        globalLocation.replace(globalLocation.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);\n    };\n    var getDOMLocation = function () {\n        var path = decodePath(getHashPath());\n        warning((!basename || Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"h\"])(path, basename)), 'You are attempting to use a basename on a page whose URL path does not begin ' +\n            'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\n        if (basename) {\n            path = Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"d\"])(path, basename);\n        }\n        return Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"c\"])(path, undefined, Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"b\"])(keyLength));\n    };\n    var transitionManager = createTransitionManager();\n    var setState = function (nextState) {\n        Object.assign(history, nextState);\n        history.length = globalHistory.length;\n        transitionManager.notifyListeners(history.location, history.action);\n    };\n    var handleHashChange = function () {\n        var path = getHashPath();\n        var encodedPath = encodePath(path);\n        if (path !== encodedPath) {\n            // Ensure we always have a properly-encoded hash.\n            replaceHashPath(encodedPath);\n        }\n        else {\n            var location = getDOMLocation();\n            var prevLocation = history.location;\n            if (!forceNextPop && Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"l\"])(prevLocation, location)) {\n                return; // A hashchange doesn't always == location change.\n            }\n            if (ignorePath === Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"e\"])(location)) {\n                return; // Ignore this change; we already setState in push/replace.\n            }\n            ignorePath = null;\n            handlePop(location);\n        }\n    };\n    var handlePop = function (location) {\n        if (forceNextPop) {\n            forceNextPop = false;\n            setState();\n        }\n        else {\n            var action_2 = 'POP';\n            transitionManager.confirmTransitionTo(location, action_2, getUserConfirmation, function (ok) {\n                if (ok) {\n                    setState({ action: action_2, location: location });\n                }\n                else {\n                    revertPop(location);\n                }\n            });\n        }\n    };\n    var revertPop = function (fromLocation) {\n        var toLocation = history.location;\n        // TODO: We could probably make this more reliable by\n        // keeping a list of paths we've seen in sessionStorage.\n        // Instead, we just default to 0 for paths we don't know.\n        var toIndex = allPaths.lastIndexOf(Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"e\"])(toLocation));\n        var fromIndex = allPaths.lastIndexOf(Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"e\"])(fromLocation));\n        if (toIndex === -1) {\n            toIndex = 0;\n        }\n        if (fromIndex === -1) {\n            fromIndex = 0;\n        }\n        var delta = toIndex - fromIndex;\n        if (delta) {\n            forceNextPop = true;\n            go(delta);\n        }\n    };\n    // Ensure the hash is encoded properly before doing anything else.\n    var path = getHashPath();\n    var encodedPath = encodePath(path);\n    if (path !== encodedPath) {\n        replaceHashPath(encodedPath);\n    }\n    var initialLocation = getDOMLocation();\n    var allPaths = [Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"e\"])(initialLocation)];\n    // Public interface\n    var createHref = function (location) { return ('#' + encodePath(basename + Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"e\"])(location))); };\n    var push = function (path, state) {\n        warning(state === undefined, 'Hash history cannot push state; it is ignored');\n        var action = 'PUSH';\n        var location = Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"c\"])(path, undefined, Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"b\"])(keyLength), history.location);\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n            if (!ok) {\n                return;\n            }\n            var path = Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"e\"])(location);\n            var encodedPath = encodePath(basename + path);\n            var hashChanged = getHashPath() !== encodedPath;\n            if (hashChanged) {\n                // We cannot tell if a hashchange was caused by a PUSH, so we'd\n                // rather setState here and ignore the hashchange. The caveat here\n                // is that other hash histories in the page will consider it a POP.\n                ignorePath = path;\n                pushHashPath(encodedPath);\n                var prevIndex = allPaths.lastIndexOf(Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"e\"])(history.location));\n                var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n                nextPaths.push(path);\n                allPaths = nextPaths;\n                setState({ action: action, location: location });\n            }\n            else {\n                warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');\n                setState();\n            }\n        });\n    };\n    var replace = function (path, state) {\n        warning(state === undefined, 'Hash history cannot replace state; it is ignored');\n        var action = 'REPLACE';\n        var location = Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"c\"])(path, undefined, Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"b\"])(keyLength), history.location);\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n            if (!ok) {\n                return;\n            }\n            var path = Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"e\"])(location);\n            var encodedPath = encodePath(basename + path);\n            var hashChanged = getHashPath() !== encodedPath;\n            if (hashChanged) {\n                // We cannot tell if a hashchange was caused by a REPLACE, so we'd\n                // rather setState here and ignore the hashchange. The caveat here\n                // is that other hash histories in the page will consider it a POP.\n                ignorePath = path;\n                replaceHashPath(encodedPath);\n            }\n            var prevIndex = allPaths.indexOf(Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_2__[\"e\"])(history.location));\n            if (prevIndex !== -1) {\n                allPaths[prevIndex] = path;\n            }\n            setState({ action: action, location: location });\n        });\n    };\n    var go = function (n) {\n        warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');\n        globalHistory.go(n);\n    };\n    var goBack = function () { return go(-1); };\n    var goForward = function () { return go(1); };\n    var checkDOMListeners = function (win, delta) {\n        listenerCount += delta;\n        if (listenerCount === 1) {\n            win.addEventListener(HashChangeEvent$1, handleHashChange);\n        }\n        else if (listenerCount === 0) {\n            win.removeEventListener(HashChangeEvent$1, handleHashChange);\n        }\n    };\n    var block = function (prompt) {\n        if (prompt === void 0) { prompt = ''; }\n        var unblock = transitionManager.setPrompt(prompt);\n        if (!isBlocked) {\n            checkDOMListeners(win, 1);\n            isBlocked = true;\n        }\n        return function () {\n            if (isBlocked) {\n                isBlocked = false;\n                checkDOMListeners(win, -1);\n            }\n            return unblock();\n        };\n    };\n    var listen = function (listener) {\n        var unlisten = transitionManager.appendListener(listener);\n        checkDOMListeners(win, 1);\n        return function () {\n            checkDOMListeners(win, -1);\n            unlisten();\n        };\n    };\n    var history = {\n        length: globalHistory.length,\n        action: 'POP',\n        location: initialLocation,\n        createHref: createHref,\n        push: push,\n        replace: replace,\n        go: go,\n        goBack: goBack,\n        goForward: goForward,\n        block: block,\n        listen: listen,\n        win: win\n    };\n    return history;\n};\nvar getLocation = function (location, root) {\n    // Remove the root URL if found at beginning of string\n    var pathname = location.pathname.indexOf(root) == 0 ?\n        '/' + location.pathname.slice(root.length) :\n        location.pathname;\n    return Object.assign({}, location, { pathname: pathname });\n};\nvar HISTORIES = {\n    'browser': createBrowserHistory,\n    'hash': createHashHistory\n};\nvar Router = /** @class */ (function () {\n    function Router(hostRef) {\n        var _this = this;\n        Object(_index_7f90bc21_js__WEBPACK_IMPORTED_MODULE_0__[\"r\"])(this, hostRef);\n        this.root = '/';\n        this.historyType = 'browser';\n        // A suffix to append to the page title whenever\n        // it's updated through RouteTitle\n        this.titleSuffix = '';\n        this.routeViewsUpdated = function (options) {\n            if (options === void 0) { options = {}; }\n            if (_this.history && options.scrollToId && _this.historyType === 'browser') {\n                var elm = _this.history.win.document.getElementById(options.scrollToId);\n                if (elm) {\n                    return elm.scrollIntoView();\n                }\n            }\n            _this.scrollTo(options.scrollTopOffset || _this.scrollTopOffset);\n        };\n        this.isServer = Object(_index_7f90bc21_js__WEBPACK_IMPORTED_MODULE_0__[\"e\"])(this, \"isServer\");\n        this.queue = Object(_index_7f90bc21_js__WEBPACK_IMPORTED_MODULE_0__[\"e\"])(this, \"queue\");\n    }\n    Router.prototype.componentWillLoad = function () {\n        var _this = this;\n        this.history = HISTORIES[this.historyType](this.el.ownerDocument.defaultView);\n        this.history.listen(function (location) {\n            location = getLocation(location, _this.root);\n            _this.location = location;\n        });\n        this.location = getLocation(this.history.location, this.root);\n    };\n    Router.prototype.scrollTo = function (scrollToLocation) {\n        var history = this.history;\n        if (scrollToLocation == null || this.isServer || !history) {\n            return;\n        }\n        if (history.action === 'POP' && Array.isArray(history.location.scrollPosition)) {\n            return this.queue.write(function () {\n                if (history && history.location && Array.isArray(history.location.scrollPosition)) {\n                    history.win.scrollTo(history.location.scrollPosition[0], history.location.scrollPosition[1]);\n                }\n            });\n        }\n        // okay, the frame has passed. Go ahead and render now\n        return this.queue.write(function () {\n            history.win.scrollTo(0, scrollToLocation);\n        });\n    };\n    Router.prototype.render = function () {\n        if (!this.location || !this.history) {\n            return;\n        }\n        var state = {\n            historyType: this.historyType,\n            location: this.location,\n            titleSuffix: this.titleSuffix,\n            root: this.root,\n            history: this.history,\n            routeViewsUpdated: this.routeViewsUpdated\n        };\n        return (Object(_index_7f90bc21_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(_active_router_9e2533ec_js__WEBPACK_IMPORTED_MODULE_1__[\"A\"].Provider, { state: state }, Object(_index_7f90bc21_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(\"slot\", null)));\n    };\n    Object.defineProperty(Router.prototype, \"el\", {\n        get: function () { return Object(_index_7f90bc21_js__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(this); },\n        enumerable: false,\n        configurable: true\n    });\n    return Router;\n}());\n\n\n\n//# sourceURL=webpack:///../text-editor/dist/esm-es5/stencil-router.entry.js?");

/***/ })

}]);