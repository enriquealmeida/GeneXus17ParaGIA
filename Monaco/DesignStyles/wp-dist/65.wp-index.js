(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[65],{

/***/ "../../node_modules/@genexus/gemini/dist/esm-es5/gxg-splitter.entry.js":
/*!**********************************************************************************************************!*\
  !*** /__w/gx-web-editors/gx-web-editors/node_modules/@genexus/gemini/dist/esm-es5/gxg-splitter.entry.js ***!
  \**********************************************************************************************************/
/*! exports provided: gxg_splitter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"gxg_splitter\", function() { return GxgSplitter; });\n/* harmony import */ var _index_09b1517f_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-09b1517f.js */ \"../../node_modules/@genexus/gemini/dist/esm-es5/index-09b1517f.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n// The programming goals of Split.js are to deliver readable, understandable and\n// maintainable code, while at the same time manually optimizing for tiny minified file size,\n// browser compatibility without additional requirements\n// and very few assumptions about the user's page layout.\nvar global = typeof window !== 'undefined' ? window : null;\nvar ssr = global === null;\nvar document$1 = !ssr ? global.document : undefined;\n// Save a couple long function names that are used frequently.\n// This optimization saves around 400 bytes.\nvar addEventListener = 'addEventListener';\nvar removeEventListener = 'removeEventListener';\nvar getBoundingClientRect = 'getBoundingClientRect';\nvar gutterStartDragging = '_a';\nvar aGutterSize = '_b';\nvar bGutterSize = '_c';\nvar HORIZONTAL = 'horizontal';\nvar NOOP = function () { return false; };\n// Helper function determines which prefixes of CSS calc we need.\n// We only need to do this once on startup, when this anonymous function is called.\n//\n// Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\n// http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\nvar calc = ssr\n    ? 'calc'\n    : ((['', '-webkit-', '-moz-', '-o-']\n        .filter(function (prefix) {\n        var el = document$1.createElement('div');\n        el.style.cssText = \"width:\" + prefix + \"calc(9px)\";\n        return !!el.style.length;\n    })\n        .shift()) + \"calc\");\n// Helper function checks if its argument is a string-like type\nvar isString = function (v) { return typeof v === 'string' || v instanceof String; };\n// Helper function allows elements and string selectors to be used\n// interchangeably. In either case an element is returned. This allows us to\n// do `Split([elem1, elem2])` as well as `Split(['#id1', '#id2'])`.\nvar elementOrSelector = function (el) {\n    if (isString(el)) {\n        var ele = document$1.querySelector(el);\n        if (!ele) {\n            throw new Error((\"Selector \" + el + \" did not match a DOM element\"));\n        }\n        return ele;\n    }\n    return el;\n};\n// Helper function gets a property from the properties object, with a default fallback\nvar getOption = function (options, propName, def) {\n    var value = options[propName];\n    if (value !== undefined) {\n        return value;\n    }\n    return def;\n};\nvar getGutterSize = function (gutterSize, isFirst, isLast, gutterAlign) {\n    if (isFirst) {\n        if (gutterAlign === 'end') {\n            return 0;\n        }\n        if (gutterAlign === 'center') {\n            return gutterSize / 2;\n        }\n    }\n    else if (isLast) {\n        if (gutterAlign === 'start') {\n            return 0;\n        }\n        if (gutterAlign === 'center') {\n            return gutterSize / 2;\n        }\n    }\n    return gutterSize;\n};\n// Default options\nvar defaultGutterFn = function (i, gutterDirection) {\n    var gut = document$1.createElement('div');\n    gut.className = \"gutter gutter-\" + gutterDirection;\n    return gut;\n};\nvar defaultElementStyleFn = function (dim, size, gutSize) {\n    var style = {};\n    if (!isString(size)) {\n        style[dim] = calc + \"(\" + size + \"% - \" + gutSize + \"px)\";\n    }\n    else {\n        style[dim] = size;\n    }\n    return style;\n};\nvar defaultGutterStyleFn = function (dim, gutSize) {\n    var obj;\n    return ((obj = {}, obj[dim] = (gutSize + \"px\"), obj));\n};\n// The main function to initialize a split. Split.js thinks about each pair\n// of elements as an independant pair. Dragging the gutter between two elements\n// only changes the dimensions of elements in that pair. This is key to understanding\n// how the following functions operate, since each function is bound to a pair.\n//\n// A pair object is shaped like this:\n//\n// {\n//     a: DOM element,\n//     b: DOM element,\n//     aMin: Number,\n//     bMin: Number,\n//     dragging: Boolean,\n//     parent: DOM element,\n//     direction: 'horizontal' | 'vertical'\n// }\n//\n// The basic sequence:\n//\n// 1. Set defaults to something sane. `options` doesn't have to be passed at all.\n// 2. Initialize a bunch of strings based on the direction we're splitting.\n//    A lot of the behavior in the rest of the library is paramatized down to\n//    rely on CSS strings and classes.\n// 3. Define the dragging helper functions, and a few helpers to go with them.\n// 4. Loop through the elements while pairing them off. Every pair gets an\n//    `pair` object and a gutter.\n// 5. Actually size the pair elements, insert gutters and attach event listeners.\nvar Split = function (idsOption, options) {\n    if (options === void 0)\n        options = {};\n    if (ssr) {\n        return {};\n    }\n    var ids = idsOption;\n    var dimension;\n    var clientAxis;\n    var position;\n    var positionEnd;\n    var clientSize;\n    var elements;\n    // Allow HTMLCollection to be used as an argument when supported\n    if (Array.from) {\n        ids = Array.from(ids);\n    }\n    // All DOM elements in the split should have a common parent. We can grab\n    // the first elements parent and hope users read the docs because the\n    // behavior will be whacky otherwise.\n    var firstElement = elementOrSelector(ids[0]);\n    var parent = firstElement.parentNode;\n    var parentStyle = getComputedStyle ? getComputedStyle(parent) : null;\n    var parentFlexDirection = parentStyle ? parentStyle.flexDirection : null;\n    // Set default options.sizes to equal percentages of the parent element.\n    var sizes = getOption(options, 'sizes') || ids.map(function () { return 100 / ids.length; });\n    // Standardize minSize and maxSize to an array if it isn't already.\n    // This allows minSize and maxSize to be passed as a number.\n    var minSize = getOption(options, 'minSize', 100);\n    var minSizes = Array.isArray(minSize) ? minSize : ids.map(function () { return minSize; });\n    var maxSize = getOption(options, 'maxSize', Infinity);\n    var maxSizes = Array.isArray(maxSize) ? maxSize : ids.map(function () { return maxSize; });\n    // Get other options\n    var expandToMin = getOption(options, 'expandToMin', false);\n    var gutterSize = getOption(options, 'gutterSize', 10);\n    var gutterAlign = getOption(options, 'gutterAlign', 'center');\n    var snapOffset = getOption(options, 'snapOffset', 30);\n    var dragInterval = getOption(options, 'dragInterval', 1);\n    var direction = getOption(options, 'direction', HORIZONTAL);\n    var cursor = getOption(options, 'cursor', direction === HORIZONTAL ? 'col-resize' : 'row-resize');\n    var gutter = getOption(options, 'gutter', defaultGutterFn);\n    var elementStyle = getOption(options, 'elementStyle', defaultElementStyleFn);\n    var gutterStyle = getOption(options, 'gutterStyle', defaultGutterStyleFn);\n    // 2. Initialize a bunch of strings based on the direction we're splitting.\n    // A lot of the behavior in the rest of the library is paramatized down to\n    // rely on CSS strings and classes.\n    if (direction === HORIZONTAL) {\n        dimension = 'width';\n        clientAxis = 'clientX';\n        position = 'left';\n        positionEnd = 'right';\n        clientSize = 'clientWidth';\n    }\n    else if (direction === 'vertical') {\n        dimension = 'height';\n        clientAxis = 'clientY';\n        position = 'top';\n        positionEnd = 'bottom';\n        clientSize = 'clientHeight';\n    }\n    // 3. Define the dragging helper functions, and a few helpers to go with them.\n    // Each helper is bound to a pair object that contains its metadata. This\n    // also makes it easy to store references to listeners that that will be\n    // added and removed.\n    //\n    // Even though there are no other functions contained in them, aliasing\n    // this to self saves 50 bytes or so since it's used so frequently.\n    //\n    // The pair object saves metadata like dragging state, position and\n    // event listener references.\n    function setElementSize(el, size, gutSize, i) {\n        // Split.js allows setting sizes via numbers (ideally), or if you must,\n        // by string, like '300px'. This is less than ideal, because it breaks\n        // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\n        // make sure you calculate the gutter size by hand.\n        var style = elementStyle(dimension, size, gutSize, i);\n        Object.keys(style).forEach(function (prop) {\n            // eslint-disable-next-line no-param-reassign\n            el.style[prop] = style[prop];\n        });\n    }\n    function setGutterSize(gutterElement, gutSize, i) {\n        var style = gutterStyle(dimension, gutSize, i);\n        Object.keys(style).forEach(function (prop) {\n            // eslint-disable-next-line no-param-reassign\n            gutterElement.style[prop] = style[prop];\n        });\n    }\n    function getSizes() {\n        return elements.map(function (element) { return element.size; });\n    }\n    // Supports touch events, but not multitouch, so only the first\n    // finger `touches[0]` is counted.\n    function getMousePosition(e) {\n        if ('touches' in e) {\n            return e.touches[0][clientAxis];\n        }\n        return e[clientAxis];\n    }\n    // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\n    // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\n    // which allows the viewport to be resized without additional logic.\n    // Element a's size is the same as offset. b's size is total size - a size.\n    // Both sizes are calculated from the initial parent percentage,\n    // then the gutter size is subtracted.\n    function adjust(offset) {\n        var a = elements[this.a];\n        var b = elements[this.b];\n        var percentage = a.size + b.size;\n        a.size = (offset / this.size) * percentage;\n        b.size = percentage - (offset / this.size) * percentage;\n        setElementSize(a.element, a.size, this[aGutterSize], a.i);\n        setElementSize(b.element, b.size, this[bGutterSize], b.i);\n    }\n    // drag, where all the magic happens. The logic is really quite simple:\n    //\n    // 1. Ignore if the pair is not dragging.\n    // 2. Get the offset of the event.\n    // 3. Snap offset to min if within snappable range (within min + snapOffset).\n    // 4. Actually adjust each element in the pair to offset.\n    //\n    // ---------------------------------------------------------------------\n    // |    | <- a.minSize               ||              b.minSize -> |    |\n    // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\n    // |    |  |                         ||                        |  |    |\n    // |    |  |                         ||                        |  |    |\n    // ---------------------------------------------------------------------\n    // | <- this.start                                        this.size -> |\n    function drag(e) {\n        var offset;\n        var a = elements[this.a];\n        var b = elements[this.b];\n        if (!this.dragging) {\n            return;\n        }\n        // Get the offset of the event from the first side of the\n        // pair `this.start`. Then offset by the initial position of the\n        // mouse compared to the gutter size.\n        offset =\n            getMousePosition(e) -\n                this.start +\n                (this[aGutterSize] - this.dragOffset);\n        if (dragInterval > 1) {\n            offset = Math.round(offset / dragInterval) * dragInterval;\n        }\n        // If within snapOffset of min or max, set offset to min or max.\n        // snapOffset buffers a.minSize and b.minSize, so logic is opposite for both.\n        // Include the appropriate gutter sizes to prevent overflows.\n        if (offset <= a.minSize + snapOffset + this[aGutterSize]) {\n            offset = a.minSize + this[aGutterSize];\n        }\n        else if (offset >=\n            this.size - (b.minSize + snapOffset + this[bGutterSize])) {\n            offset = this.size - (b.minSize + this[bGutterSize]);\n        }\n        if (offset >= a.maxSize - snapOffset + this[aGutterSize]) {\n            offset = a.maxSize + this[aGutterSize];\n        }\n        else if (offset <=\n            this.size - (b.maxSize - snapOffset + this[bGutterSize])) {\n            offset = this.size - (b.maxSize + this[bGutterSize]);\n        }\n        // Actually adjust the size.\n        adjust.call(this, offset);\n        // Call the drag callback continously. Don't do anything too intensive\n        // in this callback.\n        getOption(options, 'onDrag', NOOP)(getSizes());\n    }\n    // Cache some important sizes when drag starts, so we don't have to do that\n    // continously:\n    //\n    // `size`: The total size of the pair. First + second + first gutter + second gutter.\n    // `start`: The leading side of the first element.\n    //\n    // ------------------------------------------------\n    // |      aGutterSize -> |||                      |\n    // |                     |||                      |\n    // |                     |||                      |\n    // |                     ||| <- bGutterSize       |\n    // ------------------------------------------------\n    // | <- start                             size -> |\n    function calculateSizes() {\n        // Figure out the parent size minus padding.\n        var a = elements[this.a].element;\n        var b = elements[this.b].element;\n        var aBounds = a[getBoundingClientRect]();\n        var bBounds = b[getBoundingClientRect]();\n        this.size =\n            aBounds[dimension] +\n                bBounds[dimension] +\n                this[aGutterSize] +\n                this[bGutterSize];\n        this.start = aBounds[position];\n        this.end = aBounds[positionEnd];\n    }\n    function innerSize(element) {\n        // Return nothing if getComputedStyle is not supported (< IE9)\n        // Or if parent element has no layout yet\n        if (!getComputedStyle) {\n            return null;\n        }\n        var computedStyle = getComputedStyle(element);\n        if (!computedStyle) {\n            return null;\n        }\n        var size = element[clientSize];\n        if (size === 0) {\n            return null;\n        }\n        if (direction === HORIZONTAL) {\n            size -=\n                parseFloat(computedStyle.paddingLeft) +\n                    parseFloat(computedStyle.paddingRight);\n        }\n        else {\n            size -=\n                parseFloat(computedStyle.paddingTop) +\n                    parseFloat(computedStyle.paddingBottom);\n        }\n        return size;\n    }\n    // When specifying percentage sizes that are less than the computed\n    // size of the element minus the gutter, the lesser percentages must be increased\n    // (and decreased from the other elements) to make space for the pixels\n    // subtracted by the gutters.\n    function trimToMin(sizesToTrim) {\n        // Try to get inner size of parent element.\n        // If it's no supported, return original sizes.\n        var parentSize = innerSize(parent);\n        if (parentSize === null) {\n            return sizesToTrim;\n        }\n        if (minSizes.reduce(function (a, b) { return a + b; }, 0) > parentSize) {\n            return sizesToTrim;\n        }\n        // Keep track of the excess pixels, the amount of pixels over the desired percentage\n        // Also keep track of the elements with pixels to spare, to decrease after if needed\n        var excessPixels = 0;\n        var toSpare = [];\n        var pixelSizes = sizesToTrim.map(function (size, i) {\n            // Convert requested percentages to pixel sizes\n            var pixelSize = (parentSize * size) / 100;\n            var elementGutterSize = getGutterSize(gutterSize, i === 0, i === sizesToTrim.length - 1, gutterAlign);\n            var elementMinSize = minSizes[i] + elementGutterSize;\n            // If element is too smal, increase excess pixels by the difference\n            // and mark that it has no pixels to spare\n            if (pixelSize < elementMinSize) {\n                excessPixels += elementMinSize - pixelSize;\n                toSpare.push(0);\n                return elementMinSize;\n            }\n            // Otherwise, mark the pixels it has to spare and return it's original size\n            toSpare.push(pixelSize - elementMinSize);\n            return pixelSize;\n        });\n        // If nothing was adjusted, return the original sizes\n        if (excessPixels === 0) {\n            return sizesToTrim;\n        }\n        return pixelSizes.map(function (pixelSize, i) {\n            var newPixelSize = pixelSize;\n            // While there's still pixels to take, and there's enough pixels to spare,\n            // take as many as possible up to the total excess pixels\n            if (excessPixels > 0 && toSpare[i] - excessPixels > 0) {\n                var takenPixels = Math.min(excessPixels, toSpare[i] - excessPixels);\n                // Subtract the amount taken for the next iteration\n                excessPixels -= takenPixels;\n                newPixelSize = pixelSize - takenPixels;\n            }\n            // Return the pixel size adjusted as a percentage\n            return (newPixelSize / parentSize) * 100;\n        });\n    }\n    // stopDragging is very similar to startDragging in reverse.\n    function stopDragging() {\n        var self = this;\n        var a = elements[self.a].element;\n        var b = elements[self.b].element;\n        if (self.dragging) {\n            getOption(options, 'onDragEnd', NOOP)(getSizes());\n        }\n        self.dragging = false;\n        // Remove the stored event listeners. This is why we store them.\n        global[removeEventListener]('mouseup', self.stop);\n        global[removeEventListener]('touchend', self.stop);\n        global[removeEventListener]('touchcancel', self.stop);\n        global[removeEventListener]('mousemove', self.move);\n        global[removeEventListener]('touchmove', self.move);\n        // Clear bound function references\n        self.stop = null;\n        self.move = null;\n        a[removeEventListener]('selectstart', NOOP);\n        a[removeEventListener]('dragstart', NOOP);\n        b[removeEventListener]('selectstart', NOOP);\n        b[removeEventListener]('dragstart', NOOP);\n        a.style.userSelect = '';\n        a.style.webkitUserSelect = '';\n        a.style.MozUserSelect = '';\n        a.style.pointerEvents = '';\n        b.style.userSelect = '';\n        b.style.webkitUserSelect = '';\n        b.style.MozUserSelect = '';\n        b.style.pointerEvents = '';\n        self.gutter.style.cursor = '';\n        self.parent.style.cursor = '';\n        document$1.body.style.cursor = '';\n    }\n    // startDragging calls `calculateSizes` to store the inital size in the pair object.\n    // It also adds event listeners for mouse/touch events,\n    // and prevents selection while dragging so avoid the selecting text.\n    function startDragging(e) {\n        // Right-clicking can't start dragging.\n        if ('button' in e && e.button !== 0) {\n            return;\n        }\n        // Alias frequently used variables to save space. 200 bytes.\n        var self = this;\n        var a = elements[self.a].element;\n        var b = elements[self.b].element;\n        // Call the onDragStart callback.\n        if (!self.dragging) {\n            getOption(options, 'onDragStart', NOOP)(getSizes());\n        }\n        // Don't actually drag the element. We emulate that in the drag function.\n        e.preventDefault();\n        // Set the dragging property of the pair object.\n        self.dragging = true;\n        // Create two event listeners bound to the same pair object and store\n        // them in the pair object.\n        self.move = drag.bind(self);\n        self.stop = stopDragging.bind(self);\n        // All the binding. `window` gets the stop events in case we drag out of the elements.\n        global[addEventListener]('mouseup', self.stop);\n        global[addEventListener]('touchend', self.stop);\n        global[addEventListener]('touchcancel', self.stop);\n        global[addEventListener]('mousemove', self.move);\n        global[addEventListener]('touchmove', self.move);\n        // Disable selection. Disable!\n        a[addEventListener]('selectstart', NOOP);\n        a[addEventListener]('dragstart', NOOP);\n        b[addEventListener]('selectstart', NOOP);\n        b[addEventListener]('dragstart', NOOP);\n        a.style.userSelect = 'none';\n        a.style.webkitUserSelect = 'none';\n        a.style.MozUserSelect = 'none';\n        a.style.pointerEvents = 'none';\n        b.style.userSelect = 'none';\n        b.style.webkitUserSelect = 'none';\n        b.style.MozUserSelect = 'none';\n        b.style.pointerEvents = 'none';\n        // Set the cursor at multiple levels\n        self.gutter.style.cursor = cursor;\n        self.parent.style.cursor = cursor;\n        document$1.body.style.cursor = cursor;\n        // Cache the initial sizes of the pair.\n        calculateSizes.call(self);\n        // Determine the position of the mouse compared to the gutter\n        self.dragOffset = getMousePosition(e) - self.end;\n    }\n    // adjust sizes to ensure percentage is within min size and gutter.\n    sizes = trimToMin(sizes);\n    // 5. Create pair and element objects. Each pair has an index reference to\n    // elements `a` and `b` of the pair (first and second elements).\n    // Loop through the elements while pairing them off. Every pair gets a\n    // `pair` object and a gutter.\n    //\n    // Basic logic:\n    //\n    // - Starting with the second element `i > 0`, create `pair` objects with\n    //   `a = i - 1` and `b = i`\n    // - Set gutter sizes based on the _pair_ being first/last. The first and last\n    //   pair have gutterSize / 2, since they only have one half gutter, and not two.\n    // - Create gutter elements and add event listeners.\n    // - Set the size of the elements, minus the gutter sizes.\n    //\n    // -----------------------------------------------------------------------\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\n    // |             |                     |                  |              |\n    // |           pair 0                pair 1             pair 2           |\n    // |             |                     |                  |              |\n    // -----------------------------------------------------------------------\n    var pairs = [];\n    elements = ids.map(function (id, i) {\n        // Create the element object.\n        var element = {\n            element: elementOrSelector(id),\n            size: sizes[i],\n            minSize: minSizes[i],\n            maxSize: maxSizes[i],\n            i: i,\n        };\n        var pair;\n        if (i > 0) {\n            // Create the pair object with its metadata.\n            pair = {\n                a: i - 1,\n                b: i,\n                dragging: false,\n                direction: direction,\n                parent: parent,\n            };\n            pair[aGutterSize] = getGutterSize(gutterSize, i - 1 === 0, false, gutterAlign);\n            pair[bGutterSize] = getGutterSize(gutterSize, false, i === ids.length - 1, gutterAlign);\n            // if the parent has a reverse flex-direction, switch the pair elements.\n            if (parentFlexDirection === 'row-reverse' ||\n                parentFlexDirection === 'column-reverse') {\n                var temp = pair.a;\n                pair.a = pair.b;\n                pair.b = temp;\n            }\n        }\n        // Determine the size of the current element. IE8 is supported by\n        // staticly assigning sizes without draggable gutters. Assigns a string\n        // to `size`.\n        //\n        // Create gutter elements for each pair.\n        if (i > 0) {\n            var gutterElement = gutter(i, direction, element.element);\n            setGutterSize(gutterElement, gutterSize, i);\n            // Save bound event listener for removal later\n            pair[gutterStartDragging] = startDragging.bind(pair);\n            // Attach bound event listener\n            gutterElement[addEventListener]('mousedown', pair[gutterStartDragging]);\n            gutterElement[addEventListener]('touchstart', pair[gutterStartDragging]);\n            parent.insertBefore(gutterElement, element.element);\n            pair.gutter = gutterElement;\n        }\n        setElementSize(element.element, element.size, getGutterSize(gutterSize, i === 0, i === ids.length - 1, gutterAlign), i);\n        // After the first iteration, and we have a pair object, append it to the\n        // list of pairs.\n        if (i > 0) {\n            pairs.push(pair);\n        }\n        return element;\n    });\n    function adjustToMin(element) {\n        var isLast = element.i === pairs.length;\n        var pair = isLast ? pairs[element.i - 1] : pairs[element.i];\n        calculateSizes.call(pair);\n        var size = isLast\n            ? pair.size - element.minSize - pair[bGutterSize]\n            : element.minSize + pair[aGutterSize];\n        adjust.call(pair, size);\n    }\n    elements.forEach(function (element) {\n        var computedSize = element.element[getBoundingClientRect]()[dimension];\n        if (computedSize < element.minSize) {\n            if (expandToMin) {\n                adjustToMin(element);\n            }\n            else {\n                // eslint-disable-next-line no-param-reassign\n                element.minSize = computedSize;\n            }\n        }\n    });\n    function setSizes(newSizes) {\n        var trimmed = trimToMin(newSizes);\n        trimmed.forEach(function (newSize, i) {\n            if (i > 0) {\n                var pair = pairs[i - 1];\n                var a = elements[pair.a];\n                var b = elements[pair.b];\n                a.size = trimmed[i - 1];\n                b.size = newSize;\n                setElementSize(a.element, a.size, pair[aGutterSize], a.i);\n                setElementSize(b.element, b.size, pair[bGutterSize], b.i);\n            }\n        });\n    }\n    function destroy(preserveStyles, preserveGutter) {\n        pairs.forEach(function (pair) {\n            if (preserveGutter !== true) {\n                pair.parent.removeChild(pair.gutter);\n            }\n            else {\n                pair.gutter[removeEventListener]('mousedown', pair[gutterStartDragging]);\n                pair.gutter[removeEventListener]('touchstart', pair[gutterStartDragging]);\n            }\n            if (preserveStyles !== true) {\n                var style = elementStyle(dimension, pair.a.size, pair[aGutterSize]);\n                Object.keys(style).forEach(function (prop) {\n                    elements[pair.a].element.style[prop] = '';\n                    elements[pair.b].element.style[prop] = '';\n                });\n            }\n        });\n    }\n    return {\n        setSizes: setSizes,\n        getSizes: getSizes,\n        collapse: function collapse(i) {\n            adjustToMin(elements[i]);\n        },\n        destroy: destroy,\n        parent: parent,\n        pairs: pairs,\n    };\n};\nvar splitterCss = \":host{display:block;width:100%;height:100%;overflow:hidden}:host ::slotted(.gutter-horizontal),:host ::slotted(.gutter-vertical){-webkit-transition:background-color 0.25s;transition:background-color 0.25s;background-color:var(--gray-01)}:host ::slotted(.gutter-horizontal){height:100%;float:left;cursor:col-resize;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;position:relative}:host ::slotted(.gutter-horizontal):after{right:-5px}:host ::slotted(.gutter-horizontal):before{left:-5px}:host ::slotted(.gutter-vertical){cursor:row-resize;display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-align:center;align-items:center;background-color:var(--gray-01);position:relative}:host ::slotted(.gutter-vertical):after{right:50%;-webkit-transform:rotate(90deg) translateX(6px) translateY(-2px);transform:rotate(90deg) translateX(6px) translateY(-2px)}:host ::slotted(.gutter-vertical):before{left:50%;-webkit-transform:rotate(90deg) translateX(-6px) translateY(2px);transform:rotate(90deg) translateX(-6px) translateY(2px)}:host([knob=bidirectional]) ::slotted(.gutter-horizontal):after,:host([knob=bidirectional]) ::slotted(.gutter-horizontal):before,:host([knob=bidirectional]) ::slotted(.gutter-vertical):after,:host([knob=bidirectional]) ::slotted(.gutter-vertical):before{content:\\\"\\\";width:0;height:0;border-top:4px solid transparent;border-bottom:4px solid transparent;z-index:10;position:relative;pointer-events:none;opacity:0;pointer-events:none;-webkit-transition:0.25s all;transition:0.25s all}:host([knob=bidirectional]) ::slotted(.gutter-horizontal):after,:host([knob=bidirectional]) ::slotted(.gutter-vertical):after{border-left:3px solid var(--gray-03)}:host([knob=bidirectional]) ::slotted(.gutter-horizontal):before,:host([knob=bidirectional]) ::slotted(.gutter-vertical):before{border-right:3px solid var(--gray-03)}:host([knob=bidirectional]) ::slotted(.gutter-horizontal):after{bottom:-19px;right:1px}:host([knob=bidirectional]) ::slotted(.gutter-horizontal):before{top:-19px;left:1px}:host([knob=bidirectional]) ::slotted(.gutter-vertical):after{bottom:6px;right:23px}:host([knob=bidirectional]) ::slotted(.gutter-vertical):before{top:6px;left:24px}:host([knob=bidirectional]) ::slotted(.gutter-horizontal:hover):after,:host([knob=bidirectional]) ::slotted(.gutter-vertical:hover):after{opacity:1}:host([knob=bidirectional]) ::slotted(.gutter-horizontal:hover):before,:host([knob=bidirectional]) ::slotted(.gutter-vertical:hover):before{opacity:1}:host(.knob-left-hover) ::slotted(.gutter-horizontal):before,:host(.knob-left-hover) ::slotted(.gutter-vertical):before{border-top:4px solid transparent;border-bottom:4px solid transparent;border-right:3px solid var(--color-primary-hover)}:host(.knob-right-hover) ::slotted(.gutter-horizontal):after,:host(.knob-right-hover) ::slotted(.gutter-vertical):after{border-top:4px solid transparent;border-bottom:4px solid transparent;border-left:3px solid var(--color-primary-hover)}:host(.left-collapsed-to-zero) ::slotted(.gutter),:host(.right-collapsed-to-zero) ::slotted(.gutter){pointer-events:none}:host(.collapsed-to-zero) ::slotted(.knob){pointer-events:auto}:host(.left-collapsed-to-zero[knob=bidirectional]) ::slotted(.gutter-horizontal):before,:host(.left-collapsed-to-zero[knob=bidirectional]) ::slotted(.gutter-vertical):before{opacity:0;pointer-events:none}:host(.left-collapsed-to-zero[knob=bidirectional]) ::slotted(.gutter-horizontal):after,:host(.left-collapsed-to-zero[knob=bidirectional]) ::slotted(.gutter-vertical):after{opacity:1}:host(.left-collapsed-to-zero[knob=bidirectional]) ::slotted(.gutter-horizontal):after{bottom:0}:host(.left-collapsed-to-zero[knob=bidirectional]) ::slotted(.gutter-vertical):after{right:3px}:host(.right-collapsed-to-zero[knob=bidirectional]) ::slotted(.gutter-horizontal):after,:host(.right-collapsed-to-zero[knob=bidirectional]) ::slotted(.gutter-vertical):after{opacity:0;pointer-events:none}:host(.right-collapsed-to-zero[knob=bidirectional]) ::slotted(.gutter-horizontal):before,:host(.right-collapsed-to-zero[knob=bidirectional]) ::slotted(.gutter-vertical):before{opacity:1}:host(.right-collapsed-to-zero[knob=bidirectional]) ::slotted(.gutter-horizontal):before{top:0}:host(.right-collapsed-to-zero[knob=bidirectional]) ::slotted(.gutter-vertical):before{left:3px}:host(.gutter-reached-right[knob=bidirectional]) ::slotted(.gutter-horizontal):after,:host(.gutter-reached-right[knob=bidirectional]) ::slotted(.gutter-vertical):after{opacity:0;pointer-events:none}:host(.gutter-reached-left[knob=bidirectional]) ::slotted(.gutter-horizontal):before,:host(.gutter-reached-left[knob=bidirectional]) ::slotted(.gutter-vertical):before{opacity:0;pointer-events:none}:host(.dragging) ::slotted(.gutter-horizontal),:host(.dragging) ::slotted(.gutter-vertical){background-color:var(--color-primary-hover)}:host(.dragging) ::slotted(.gutter-horizontal):after,:host(.dragging) ::slotted(.gutter-vertical):after{border-top:4px solid transparent;border-bottom:4px solid transparent;border-left:3px solid var(--color-on-primary)}:host(.dragging) ::slotted(.gutter-horizontal):before,:host(.dragging) ::slotted(.gutter-vertical):before{border-top:4px solid transparent;border-bottom:4px solid transparent;border-right:3px solid var(--color-on-primary)}:host(.dragging) ::slotted(.gutter-horizontal) .middle-line,:host(.dragging) ::slotted(.gutter-vertical) .middle-line{background-color:red}\";\nvar GxgSplitter = /** @class */ (function () {\n    function class_1(hostRef) {\n        Object(_index_09b1517f_js__WEBPACK_IMPORTED_MODULE_0__[\"r\"])(this, hostRef);\n        this.dragging = Object(_index_09b1517f_js__WEBPACK_IMPORTED_MODULE_0__[\"c\"])(this, \"dragging\", 7);\n        this.dragEnded = Object(_index_09b1517f_js__WEBPACK_IMPORTED_MODULE_0__[\"c\"])(this, \"dragEnded\", 7);\n        /**\n         * The splitter direction\n         */\n        this.direction = \"horizontal\";\n        /**\n         * The prescence of this attributes forces the splitter to collapse to zero\n         */\n        this.forceCollapseZero = false;\n        /**\n         * The type of knob (simple: only draggable - bidirectional: draggable and collapsable by clicking the arrows)\n         */\n        this.knob = \"bidirectional\";\n        /**\n         * The splitter min. sizes in pixels\n         */\n        this.minSize = \"0,0\";\n        /**\n         * The splitter initial sizes, in percentages. The sum should equal 100\n         */\n        this.sizes = \"50,50\";\n        this.idsArray = [];\n        this.draggingState = false;\n        this.leftCollapsedToZero = false;\n        this.rightCollapsedToZero = false;\n    }\n    class_1.prototype.makeId = function (length) {\n        var result = [];\n        var characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n        var charactersLength = characters.length;\n        for (var i = 0; i < length; i++) {\n            result.push(characters.charAt(Math.floor(Math.random() * charactersLength)));\n        }\n        result.unshift(\"a\"); // this prevents the id begining with a number, which is not allowed\n        return result.join(\"\");\n    };\n    class_1.prototype.componentWillLoad = function () {\n        var splits = this.el.querySelectorAll(\"gxg-split\");\n        splits.forEach(function (split) {\n            var randomId = this.makeId(5);\n            split.setAttribute(\"id\", randomId);\n        }.bind(this));\n    };\n    class_1.prototype.componentDidLoad = function () {\n        var _this = this;\n        this.getIds();\n        this.convertStringPropertiesToArray();\n        this.validateSizes();\n        this.split = Split(this.idsArray, {\n            gutterSize: 8,\n            cursor: \"col-resize\",\n            minSize: this.minSizeArray,\n            sizes: this.sizesArray,\n            direction: this.direction,\n            onDragStart: this.onDragStartFunc.bind(this),\n            onDrag: this.onDragFunc.bind(this),\n            onDragEnd: this.onDragEndFunc.bind(this),\n            gutter: function () {\n                var gutter = document.createElement(\"div\");\n                if (_this.knob === \"bidirectional\") {\n                    //KNOB\n                    var knob = document.createElement(\"span\");\n                    knob.classList.add(\"knob\");\n                    knob.style.width = \"var(--spacing-comp-05)\";\n                    knob.style.height = \"var(--spacing-comp-05)\";\n                    knob.style.display = \"block\";\n                    knob.style.zIndex = \"5\";\n                    knob.style.position = \"absolute\";\n                    if (_this.direction === \"vertical\") {\n                        knob.style.transform = \"rotate(90deg)\";\n                    }\n                    //KNOB middle line\n                    var knobMiddleLine = document.createElement(\"span\");\n                    knobMiddleLine.style.backgroundColor = \"var(--gray-03)\";\n                    knobMiddleLine.style.width = \"2px\";\n                    knobMiddleLine.style.height = \"16px\";\n                    knobMiddleLine.style.position = \"relative\";\n                    knobMiddleLine.style.left = \"11px\";\n                    knobMiddleLine.style.top = \"4px\";\n                    knobMiddleLine.style.display = \"block\";\n                    knobMiddleLine.style.transition = \"0.25s all\";\n                    knobMiddleLine.classList.add(\"middle-line\");\n                    knob.appendChild(knobMiddleLine);\n                    //KNOB left side\n                    var knobLeftSide = document.createElement(\"span\");\n                    knobLeftSide.style.width = \"11px\";\n                    knobLeftSide.style.height = \"var(--spacing-comp-05)\";\n                    knobLeftSide.style.display = \"block\";\n                    knobLeftSide.style.top = \"-36px\";\n                    knobLeftSide.style.left = \"6px\";\n                    knobLeftSide.style.position = \"relative\";\n                    knobLeftSide.style.borderBottomLeftRadius = \"40px\";\n                    knobLeftSide.style.borderTopLeftRadius = \"40px\";\n                    knobLeftSide.style.backgroundColor = \"transparent\";\n                    knobLeftSide.style.cursor = \"pointer\";\n                    knobLeftSide.style.zIndex = \"20\";\n                    knobLeftSide.style.pointerEvents = \"auto\";\n                    knobLeftSide.classList.add(\"left-knob\");\n                    knobLeftSide.addEventListener(\"click\", _this.knobLeftClicked.bind(_this));\n                    knobLeftSide.onmouseover = _this.knobLeftOver.bind(_this);\n                    knobLeftSide.onmouseout = _this.knobLeftOut.bind(_this);\n                    knob.appendChild(knobLeftSide);\n                    //KNOB right side\n                    var knobRightSide = document.createElement(\"span\");\n                    knobRightSide.style.width = \"11px\";\n                    knobRightSide.style.height = \"var(--spacing-comp-05)\";\n                    knobRightSide.style.display = \"block\";\n                    knobRightSide.style.top = \"-20px\";\n                    knobRightSide.style.right = \"-6px\";\n                    knobRightSide.style.position = \"relative\";\n                    knobRightSide.style.borderBottomRightRadius = \"40px\";\n                    knobRightSide.style.borderTopRightRadius = \"40px\";\n                    knobRightSide.style.backgroundColor = \"transparent\";\n                    knobRightSide.style.cursor = \"pointer\";\n                    knobRightSide.style.zIndex = \"20\";\n                    knobRightSide.style.pointerEvents = \"auto\";\n                    knobRightSide.classList.add(\"right-knob\");\n                    knobRightSide.addEventListener(\"click\", _this.knobRightClicked.bind(_this));\n                    knobRightSide.onmouseover = _this.knobRightOver.bind(_this);\n                    knobRightSide.onmouseout = _this.knobRightOut.bind(_this);\n                    knob.appendChild(knobRightSide);\n                    gutter.appendChild(knob);\n                    //End of KNOB\n                }\n                else {\n                    //KNOB\n                    var knob = document.createElement(\"span\");\n                    knob.classList.add(\"knob\");\n                    knob.style.width = \"var(--spacing-comp-05)\";\n                    knob.style.height = \"var(--spacing-comp-05)\";\n                    knob.style.display = \"block\";\n                    knob.style.zIndex = \"5\";\n                    knob.style.position = \"absolute\";\n                    if (_this.direction === \"vertical\") {\n                        knob.style.transform = \"rotate(90deg)\";\n                    }\n                    //KNOB middle line\n                    var knobMiddleLine = document.createElement(\"span\");\n                    knobMiddleLine.style.backgroundColor = \"var(--gray-03)\";\n                    knobMiddleLine.style.width = \"2px\";\n                    knobMiddleLine.style.height = \"16px\";\n                    knobMiddleLine.style.position = \"relative\";\n                    knobMiddleLine.style.left = \"11px\";\n                    knobMiddleLine.style.top = \"4px\";\n                    knobMiddleLine.style.display = \"block\";\n                    knobMiddleLine.style.transition = \"0.25s all\";\n                    knobMiddleLine.classList.add(\"middle-line\");\n                    knob.appendChild(knobMiddleLine);\n                    gutter.appendChild(knob);\n                }\n                gutter.className = \"gutter gutter-\" + _this.direction;\n                return gutter;\n            },\n        });\n        this.detectDragEndReachedMinimum();\n        //set classes\n        var slottedSplits = this.el.querySelectorAll(\"gxg-split\");\n        if (this.direction === \"horizontal\") {\n            slottedSplits.forEach(function (split) {\n                split.classList.add(\"split-horizontal\");\n            });\n        }\n    };\n    class_1.prototype.convertStringPropertiesToArray = function () {\n        this.minSizeArray = this.minSize.split(\",\").map(function (number) {\n            return parseInt(number, 10);\n        });\n        this.sizesArray = this.sizes.split(\",\").map(function (number) {\n            return parseInt(number, 10);\n        });\n    };\n    class_1.prototype.getIds = function () {\n        var slottedSplits = this.el.querySelectorAll(\"gxg-split\");\n        slottedSplits.forEach(function (split) {\n            var splitId = split.getAttribute(\"id\");\n            this.idsArray.push(\"#\" + splitId);\n        }.bind(this));\n    };\n    class_1.prototype.validateSizes = function () {\n        var totalSize = 0;\n        var eachSplitSize = 0;\n        var sizesArrayLength = this.sizesArray.length;\n        this.sizesArray.forEach(function (splitSize) {\n            totalSize += splitSize;\n        });\n        if (totalSize > 100) {\n            eachSplitSize = 100 / sizesArrayLength;\n            this.sizesArray = [];\n            for (var i = 0; i < sizesArrayLength; i++) {\n                this.sizesArray.push(eachSplitSize);\n            }\n        }\n    };\n    //KNOB\n    class_1.prototype.knobLeftClicked = function () {\n        //add class to make the transition smooth\n        var slottedSplits = this.el.querySelectorAll(\"gxg-split\");\n        slottedSplits.forEach(function (split) {\n            split.classList.add(\"smooth-transition\");\n        });\n        this.draggingState = true;\n        var middleLine = this.el.querySelector(\".middle-line\");\n        middleLine.style.backgroundColor =\n            \"var(--color-on-primary)\";\n        setTimeout(function () {\n            this.draggingState = false;\n            middleLine.style.backgroundColor =\n                \"var(--gray-03)\";\n        }.bind(this), 450);\n        if (this.forceCollapseZero) {\n            if (!this.rightCollapsedToZero) {\n                this.currentSizes = this.split.getSizes();\n                var leftSplit = slottedSplits[0];\n                var rightSplit = slottedSplits[1];\n                if (this.direction === \"horizontal\") {\n                    leftSplit.style.width = \"0\";\n                    rightSplit.style.width = \"calc(100% - 8px)\";\n                    this.leftCollapsedToZero = true;\n                }\n                else if (this.direction === \"vertical\") {\n                    leftSplit.style.height = \"0\";\n                    rightSplit.style.height = \"calc(100% - 8px)\";\n                    this.leftCollapsedToZero = true;\n                }\n                var leftKnob = this.el.querySelector(\".left-knob\");\n                leftKnob.style.pointerEvents = \"none\";\n                var middleLine_1 = this.el.querySelector(\".middle-line\");\n                middleLine_1.style.opacity = \"0\";\n                middleLine_1.style.pointerEvents = \"none\";\n                var rightKnob = this.el.querySelector(\".right-knob\");\n                rightKnob.style.top = \"-40px\";\n            }\n            else {\n                //Right split is collapsed to zero. Set sizes to last saved positions\n                this.split.setSizes(this.currentSizes);\n                this.rightCollapsedToZero = false;\n                var middleLine_2 = this.el.querySelector(\".middle-line\");\n                middleLine_2.style.opacity = \"1\";\n                middleLine_2.style.pointerEvents = \"auto\";\n                var rightKnob = this.el.querySelector(\".right-knob\");\n                rightKnob.style.pointerEvents = \"auto\";\n                var leftKnob = this.el.querySelector(\".left-knob\");\n                leftKnob.style.top = \"-36px\";\n            }\n        }\n        else {\n            this.split.collapse(0);\n        }\n        this.detectDragEndReachedMinimum();\n    };\n    class_1.prototype.knobRightClicked = function () {\n        //add class to make the transition smooth\n        var slottedSplits = this.el.querySelectorAll(\"gxg-split\");\n        slottedSplits.forEach(function (split) {\n            split.classList.add(\"smooth-transition\");\n        });\n        this.draggingState = true;\n        var middleLine = this.el.querySelector(\".middle-line\");\n        middleLine.style.backgroundColor =\n            \"var(--color-on-primary)\";\n        setTimeout(function () {\n            this.draggingState = false;\n            middleLine.style.backgroundColor =\n                \"var(--gray-03)\";\n        }.bind(this), 450);\n        if (this.forceCollapseZero) {\n            if (!this.leftCollapsedToZero) {\n                this.currentSizes = this.split.getSizes();\n                var leftSplit = slottedSplits[0];\n                var rightSplit = slottedSplits[1];\n                if (this.direction === \"horizontal\") {\n                    leftSplit.style.width = \"calc(100% - 8px)\";\n                    rightSplit.style.width = \"0\";\n                    this.rightCollapsedToZero = true;\n                }\n                else if (this.direction === \"vertical\") {\n                    leftSplit.style.height = \"calc(100% - 8px)\";\n                    rightSplit.style.height = \"0\";\n                    this.rightCollapsedToZero = true;\n                }\n                var rightKnob = this.el.querySelector(\".right-knob\");\n                rightKnob.style.pointerEvents = \"none\";\n                var middleLine_3 = this.el.querySelector(\".middle-line\");\n                middleLine_3.style.opacity = \"0\";\n                middleLine_3.style.pointerEvents = \"none\";\n                var leftKnob = this.el.querySelector(\".left-knob\");\n                leftKnob.style.top = \"-16px\";\n            }\n            else {\n                //Left split is collapsed to zero. Set sizes to last saved positions\n                this.split.setSizes(this.currentSizes);\n                this.leftCollapsedToZero = false;\n                var middleLine_4 = this.el.querySelector(\".middle-line\");\n                middleLine_4.style.opacity = \"1\";\n                middleLine_4.style.pointerEvents = \"auto\";\n                var leftKnob = this.el.querySelector(\".left-knob\");\n                leftKnob.style.pointerEvents = \"auto\";\n                var rightKnob = this.el.querySelector(\".right-knob\");\n                rightKnob.style.top = \"-20px\";\n            }\n        }\n        else {\n            this.split.collapse(1);\n        }\n        this.detectDragEndReachedMinimum();\n    };\n    class_1.prototype.knobLeftOver = function () {\n        this.el.classList.add(\"knob-left-hover\");\n    };\n    class_1.prototype.knobLeftOut = function () {\n        this.el.classList.remove(\"knob-left-hover\");\n    };\n    class_1.prototype.knobRightOver = function () {\n        this.el.classList.add(\"knob-right-hover\");\n    };\n    class_1.prototype.knobRightOut = function () {\n        this.el.classList.remove(\"knob-right-hover\");\n    };\n    //DRAG FUNCS\n    class_1.prototype.onDragStartFunc = function () {\n        this.draggingState = true;\n        //remove class that makes the transition smooth\n        var slottedSplits = this.el.querySelectorAll(\"gxg-split\");\n        slottedSplits.forEach(function (split) {\n            split.classList.remove(\"smooth-transition\");\n        });\n        var middleLine = this.el.querySelector(\".middle-line\");\n        middleLine.style.backgroundColor =\n            \"var(--color-on-primary)\";\n    };\n    class_1.prototype.onDragFunc = function () {\n        this.detectDragEndReachedMinimum();\n        this.dragging.emit(\"dragging\");\n    };\n    class_1.prototype.onDragEndFunc = function () {\n        this.draggingState = false;\n        this.dragEnded.emit(\"dragg ended\");\n        var middleLine = this.el.querySelector(\".middle-line\");\n        middleLine.style.backgroundColor =\n            \"var(--gray-03)\";\n    };\n    class_1.prototype.detectDragEndReachedMinimum = function () {\n        var splitterLength;\n        if (this.direction === \"horizontal\") {\n            splitterLength = this.el.clientWidth;\n        }\n        else if (this.direction === \"vertical\") {\n            splitterLength = this.el.clientHeight;\n        }\n        //actual sizes in percentages\n        var rightActualSize = this.split.getSizes()[1];\n        var leftActualSize = this.split.getSizes()[0];\n        //actual sizes in pixels\n        var rightActualSizePixels = Math.trunc((rightActualSize * splitterLength) / 100);\n        var leftActualSizePixels = Math.trunc((leftActualSize * splitterLength) / 100);\n        if ((rightActualSizePixels < this.minSizeArray[1] + 15 &&\n            rightActualSizePixels > this.minSizeArray[1] - 15) ||\n            (leftActualSizePixels < this.minSizeArray[0] + 15 &&\n                leftActualSizePixels > this.minSizeArray[0] - 15)) {\n            this.el.classList.add(\"gutter-reached-end\");\n            setTimeout(function () {\n                this.el.classList.remove(\"gutter-reached-end\");\n            }.bind(this), 350 // This value has to the be same as transition speed on split.scss on the .smooth-transition class\n            );\n        }\n        else {\n            this.el.classList.remove(\"gutter-reached-left\");\n            this.el.classList.remove(\"gutter-reached-right\");\n        }\n        //if guttter reached right:\n        if (rightActualSizePixels < this.minSizeArray[1] + 15 &&\n            rightActualSizePixels > this.minSizeArray[1] - 15) {\n            if (!this.forceCollapseZero) {\n                this.el.classList.add(\"gutter-reached-right\");\n                this.el.classList.remove(\"gutter-reached-left\");\n            }\n        }\n        //if guttter reached left:\n        if (leftActualSizePixels < this.minSizeArray[0] + 15 &&\n            leftActualSizePixels > this.minSizeArray[0] - 15) {\n            if (!this.forceCollapseZero) {\n                this.el.classList.add(\"gutter-reached-left\");\n                this.el.classList.remove(\"gutter-reached-right\");\n            }\n        }\n    };\n    /**\n     * This method allows to collapse the split passsed as argument\n     */\n    class_1.prototype.collapse = function (split, forceCollapseToZero) {\n        if (forceCollapseToZero === void 0) { forceCollapseToZero = false; }\n        return __awaiter(this, void 0, void 0, function () {\n            var leftKnob, rightKnob, slottedSplits, leftSplit, rightSplit, leftKnob, rightKnob, leftKnob, rightKnob;\n            return __generator(this, function (_a) {\n                if (!forceCollapseToZero) {\n                    if (split === 0) {\n                        leftKnob = this.el.querySelector(\".left-knob\");\n                        leftKnob.click();\n                    }\n                    else if (split === 1) {\n                        rightKnob = this.el.querySelector(\".right-knob\");\n                        rightKnob.click();\n                    }\n                }\n                else {\n                    slottedSplits = this.el.querySelectorAll(\"gxg-split\");\n                    slottedSplits.forEach(function (split) {\n                        split.classList.add(\"smooth-transition\");\n                    });\n                    leftSplit = slottedSplits[0];\n                    rightSplit = slottedSplits[1];\n                    if (this.direction === \"horizontal\") {\n                        if (split === 0) {\n                            leftKnob = this.el.querySelector(\".left-knob\");\n                            leftKnob.click();\n                            leftKnob.click();\n                            leftSplit.style.width = \"0\";\n                            rightSplit.style.width = \"calc(100% - 8px)\";\n                        }\n                        else if (split === 1) {\n                            rightKnob = this.el.querySelector(\".right-knob\");\n                            rightKnob.click();\n                            rightKnob.click();\n                            leftSplit.style.width = \"calc(100% - 8px)\";\n                            rightSplit.style.width = \"0\";\n                        }\n                    }\n                    else if (this.direction === \"vertical\") {\n                        if (split === 0) {\n                            leftKnob = this.el.querySelector(\".left-knob\");\n                            leftKnob.click();\n                            leftKnob.click();\n                            leftSplit.style.height = \"0\";\n                            rightSplit.style.height = \"calc(100% - 8px)\";\n                        }\n                        else if (split === 1) {\n                            rightKnob = this.el.querySelector(\".right-knob\");\n                            rightKnob.click();\n                            rightKnob.click();\n                            leftSplit.style.height = \"calc(100% - 8px)\";\n                            rightSplit.style.height = \"0\";\n                        }\n                    }\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    class_1.prototype.render = function () {\n        return (Object(_index_09b1517f_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(_index_09b1517f_js__WEBPACK_IMPORTED_MODULE_0__[\"H\"], { class: {\n                \"left-collapsed-to-zero\": this.leftCollapsedToZero,\n                \"right-collapsed-to-zero\": this.rightCollapsedToZero,\n                dragging: this.draggingState,\n            } }, Object(_index_09b1517f_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(\"slot\", null)));\n    };\n    Object.defineProperty(class_1.prototype, \"el\", {\n        get: function () { return Object(_index_09b1517f_js__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(this); },\n        enumerable: false,\n        configurable: true\n    });\n    return class_1;\n}());\nGxgSplitter.style = splitterCss;\n\n\n\n//# sourceURL=webpack:////__w/gx-web-editors/gx-web-editors/node_modules/@genexus/gemini/dist/esm-es5/gxg-splitter.entry.js?");

/***/ })

}]);