(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[22],{

/***/ "../../node_modules/@stencil/router/dist/esm/legacy/chunk-4eecdc1a.js":
/*!*********************************************************************************************************!*\
  !*** /__w/gx-web-editors/gx-web-editors/node_modules/@stencil/router/dist/esm/legacy/chunk-4eecdc1a.js ***!
  \*********************************************************************************************************/
/*! exports provided: a, b, c, d, g, i, s */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return supportsHistory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return supportsPopStateOnHashChange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return isExtraneousPopstateEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return supportsGoWithoutReloadUsingHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return getConfirmation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return isModifiedEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"s\", function() { return storageAvailable; });\nvar getConfirmation = function (win, message, callback) { return (callback(win.confirm(message))); };\nvar isModifiedEvent = function (ev) { return (ev.metaKey || ev.altKey || ev.ctrlKey || ev.shiftKey); };\n/**\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\n *\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\n */\nvar supportsHistory = function (win) {\n    var ua = win.navigator.userAgent;\n    if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\n        ua.indexOf('Mobile Safari') !== -1 &&\n        ua.indexOf('Chrome') === -1 &&\n        ua.indexOf('Windows Phone') === -1) {\n        return false;\n    }\n    return win.history && 'pushState' in win.history;\n};\n/**\n * Returns true if browser fires popstate on hash change.\n * IE10 and IE11 do not.\n */\nvar supportsPopStateOnHashChange = function (nav) { return (nav.userAgent.indexOf('Trident') === -1); };\n/**\n * Returns false if using go(n) with hash history causes a full page reload.\n */\nvar supportsGoWithoutReloadUsingHash = function (nav) { return (nav.userAgent.indexOf('Firefox') === -1); };\nvar isExtraneousPopstateEvent = function (nav, event) { return (event.state === undefined &&\n    nav.userAgent.indexOf('CriOS') === -1); };\nvar storageAvailable = function (win, type) {\n    var storage = win[type];\n    var x = '__storage_test__';\n    try {\n        storage.setItem(x, x);\n        storage.removeItem(x);\n        return true;\n    }\n    catch (e) {\n        return e instanceof DOMException && (\n        // everything except Firefox\n        e.code === 22 ||\n            // Firefox\n            e.code === 1014 ||\n            // test name field too, because code might not be present\n            // everything except Firefox\n            e.name === 'QuotaExceededError' ||\n            // Firefox\n            e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\n            // acknowledge QuotaExceededError only if there's something already stored\n            storage.length !== 0;\n    }\n};\n\n\n\n//# sourceURL=webpack:////__w/gx-web-editors/gx-web-editors/node_modules/@stencil/router/dist/esm/legacy/chunk-4eecdc1a.js?");

/***/ }),

/***/ "../../node_modules/@stencil/router/dist/esm/legacy/stencil-router.entry.js":
/*!***************************************************************************************************************!*\
  !*** /__w/gx-web-editors/gx-web-editors/node_modules/@stencil/router/dist/esm/legacy/stencil-router.entry.js ***!
  \***************************************************************************************************************/
/*! exports provided: stencil_router */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stencil_router\", function() { return Router; });\n/* harmony import */ var _stencilrouter_1307249c_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stencilrouter-1307249c.js */ \"../../node_modules/@stencil/router/dist/esm/legacy/stencilrouter-1307249c.js\");\n/* harmony import */ var _chunk_cfc6485e_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-cfc6485e.js */ \"../../node_modules/@stencil/router/dist/esm/legacy/chunk-cfc6485e.js\");\n/* harmony import */ var _chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-d2e78d53.js */ \"../../node_modules/@stencil/router/dist/esm/legacy/chunk-d2e78d53.js\");\n/* harmony import */ var _chunk_4eecdc1a_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk-4eecdc1a.js */ \"../../node_modules/@stencil/router/dist/esm/legacy/chunk-4eecdc1a.js\");\n\n\n\n\nvar warning = function (value) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    if (!value) {\n        console.warn.apply(console, args);\n    }\n};\n// Adapted from the https://github.com/ReactTraining/history and converted to TypeScript\nvar createTransitionManager = function () {\n    var prompt;\n    var listeners = [];\n    var setPrompt = function (nextPrompt) {\n        warning(prompt == null, 'A history supports only one prompt at a time');\n        prompt = nextPrompt;\n        return function () {\n            if (prompt === nextPrompt) {\n                prompt = null;\n            }\n        };\n    };\n    var confirmTransitionTo = function (location, action, getUserConfirmation, callback) {\n        // TODO: If another transition starts while we're still confirming\n        // the previous one, we may end up in a weird state. Figure out the\n        // best way to handle this.\n        if (prompt != null) {\n            var result = typeof prompt === 'function' ? prompt(location, action) : prompt;\n            if (typeof result === 'string') {\n                if (typeof getUserConfirmation === 'function') {\n                    getUserConfirmation(result, callback);\n                }\n                else {\n                    warning(false, 'A history needs a getUserConfirmation function in order to use a prompt message');\n                    callback(true);\n                }\n            }\n            else {\n                // Return false from a transition hook to cancel the transition.\n                callback(result !== false);\n            }\n        }\n        else {\n            callback(true);\n        }\n    };\n    var appendListener = function (fn) {\n        var isActive = true;\n        var listener = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            if (isActive) {\n                fn.apply(void 0, args);\n            }\n        };\n        listeners.push(listener);\n        return function () {\n            isActive = false;\n            listeners = listeners.filter(function (item) { return item !== listener; });\n        };\n    };\n    var notifyListeners = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        listeners.forEach(function (listener) { return listener.apply(void 0, args); });\n    };\n    return {\n        setPrompt: setPrompt,\n        confirmTransitionTo: confirmTransitionTo,\n        appendListener: appendListener,\n        notifyListeners: notifyListeners\n    };\n};\nvar createScrollHistory = function (win, applicationScrollKey) {\n    if (applicationScrollKey === void 0) { applicationScrollKey = 'scrollPositions'; }\n    var scrollPositions = new Map();\n    var set = function (key, value) {\n        scrollPositions.set(key, value);\n        if (Object(_chunk_4eecdc1a_js__WEBPACK_IMPORTED_MODULE_3__[\"s\"])(win, 'sessionStorage')) {\n            var arrayData_1 = [];\n            scrollPositions.forEach(function (value, key) {\n                arrayData_1.push([key, value]);\n            });\n            win.sessionStorage.setItem('scrollPositions', JSON.stringify(arrayData_1));\n        }\n    };\n    var get = function (key) {\n        return scrollPositions.get(key);\n    };\n    var has = function (key) {\n        return scrollPositions.has(key);\n    };\n    var capture = function (key) {\n        set(key, [win.scrollX, win.scrollY]);\n    };\n    if (Object(_chunk_4eecdc1a_js__WEBPACK_IMPORTED_MODULE_3__[\"s\"])(win, 'sessionStorage')) {\n        var scrollData = win.sessionStorage.getItem(applicationScrollKey);\n        scrollPositions = scrollData ?\n            new Map(JSON.parse(scrollData)) :\n            scrollPositions;\n    }\n    if ('scrollRestoration' in win.history) {\n        history.scrollRestoration = 'manual';\n    }\n    return {\n        set: set,\n        get: get,\n        has: has,\n        capture: capture\n    };\n};\n// Adapted from the https://github.com/ReactTraining/history and converted to TypeScript\nvar PopStateEvent = 'popstate';\nvar HashChangeEvent = 'hashchange';\n/**\n * Creates a history object that uses the HTML5 history API including\n * pushState, replaceState, and the popstate event.\n */\nvar createBrowserHistory = function (win, props) {\n    if (props === void 0) { props = {}; }\n    var forceNextPop = false;\n    var globalHistory = win.history;\n    var globalLocation = win.location;\n    var globalNavigator = win.navigator;\n    var canUseHistory = Object(_chunk_4eecdc1a_js__WEBPACK_IMPORTED_MODULE_3__[\"a\"])(win);\n    var needsHashChangeListener = !Object(_chunk_4eecdc1a_js__WEBPACK_IMPORTED_MODULE_3__[\"b\"])(globalNavigator);\n    var scrollHistory = createScrollHistory(win);\n    var forceRefresh = (props.forceRefresh != null) ? props.forceRefresh : false;\n    var getUserConfirmation = (props.getUserConfirmation != null) ? props.getUserConfirmation : _chunk_4eecdc1a_js__WEBPACK_IMPORTED_MODULE_3__[\"g\"];\n    var keyLength = (props.keyLength != null) ? props.keyLength : 6;\n    var basename = props.basename ? Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"s\"])(Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"a\"])(props.basename)) : '';\n    var getHistoryState = function () {\n        try {\n            return win.history.state || {};\n        }\n        catch (e) {\n            // IE 11 sometimes throws when accessing window.history.state\n            // See https://github.com/ReactTraining/history/pull/289\n            return {};\n        }\n    };\n    var getDOMLocation = function (historyState) {\n        historyState = historyState || {};\n        var key = historyState.key, state = historyState.state;\n        var pathname = globalLocation.pathname, search = globalLocation.search, hash = globalLocation.hash;\n        var path = pathname + search + hash;\n        warning((!basename || Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"h\"])(path, basename)), 'You are attempting to use a basename on a page whose URL path does not begin ' +\n            'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\n        if (basename) {\n            path = Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"b\"])(path, basename);\n        }\n        return Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"c\"])(path, state, key || Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"d\"])(keyLength));\n    };\n    var transitionManager = createTransitionManager();\n    var setState = function (nextState) {\n        // Capture location for the view before changing history.\n        scrollHistory.capture(history.location.key);\n        Object.assign(history, nextState);\n        // Set scroll position based on its previous storage value\n        history.location.scrollPosition = scrollHistory.get(history.location.key);\n        history.length = globalHistory.length;\n        transitionManager.notifyListeners(history.location, history.action);\n    };\n    var handlePopState = function (event) {\n        // Ignore extraneous popstate events in WebKit.\n        if (!Object(_chunk_4eecdc1a_js__WEBPACK_IMPORTED_MODULE_3__[\"c\"])(globalNavigator, event)) {\n            handlePop(getDOMLocation(event.state));\n        }\n    };\n    var handleHashChange = function () {\n        handlePop(getDOMLocation(getHistoryState()));\n    };\n    var handlePop = function (location) {\n        if (forceNextPop) {\n            forceNextPop = false;\n            setState();\n        }\n        else {\n            var action_1 = 'POP';\n            transitionManager.confirmTransitionTo(location, action_1, getUserConfirmation, function (ok) {\n                if (ok) {\n                    setState({ action: action_1, location: location });\n                }\n                else {\n                    revertPop(location);\n                }\n            });\n        }\n    };\n    var revertPop = function (fromLocation) {\n        var toLocation = history.location;\n        // TODO: We could probably make this more reliable by\n        // keeping a list of keys we've seen in sessionStorage.\n        // Instead, we just default to 0 for keys we don't know.\n        var toIndex = allKeys.indexOf(toLocation.key);\n        var fromIndex = allKeys.indexOf(fromLocation.key);\n        if (toIndex === -1) {\n            toIndex = 0;\n        }\n        if (fromIndex === -1) {\n            fromIndex = 0;\n        }\n        var delta = toIndex - fromIndex;\n        if (delta) {\n            forceNextPop = true;\n            go(delta);\n        }\n    };\n    var initialLocation = getDOMLocation(getHistoryState());\n    var allKeys = [initialLocation.key];\n    var listenerCount = 0;\n    var isBlocked = false;\n    // Public interface\n    var createHref = function (location) {\n        return basename + Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"e\"])(location);\n    };\n    var push = function (path, state) {\n        warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' +\n            'argument is a location-like object that already has state; it is ignored');\n        var action = 'PUSH';\n        var location = Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"c\"])(path, state, Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"d\"])(keyLength), history.location);\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n            if (!ok) {\n                return;\n            }\n            var href = createHref(location);\n            var key = location.key, state = location.state;\n            if (canUseHistory) {\n                globalHistory.pushState({ key: key, state: state }, '', href);\n                if (forceRefresh) {\n                    globalLocation.href = href;\n                }\n                else {\n                    var prevIndex = allKeys.indexOf(history.location.key);\n                    var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n                    nextKeys.push(location.key);\n                    allKeys = nextKeys;\n                    setState({ action: action, location: location });\n                }\n            }\n            else {\n                warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');\n                globalLocation.href = href;\n            }\n        });\n    };\n    var replace = function (path, state) {\n        warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' +\n            'argument is a location-like object that already has state; it is ignored');\n        var action = 'REPLACE';\n        var location = Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"c\"])(path, state, Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"d\"])(keyLength), history.location);\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n            if (!ok) {\n                return;\n            }\n            var href = createHref(location);\n            var key = location.key, state = location.state;\n            if (canUseHistory) {\n                globalHistory.replaceState({ key: key, state: state }, '', href);\n                if (forceRefresh) {\n                    globalLocation.replace(href);\n                }\n                else {\n                    var prevIndex = allKeys.indexOf(history.location.key);\n                    if (prevIndex !== -1) {\n                        allKeys[prevIndex] = location.key;\n                    }\n                    setState({ action: action, location: location });\n                }\n            }\n            else {\n                warning(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');\n                globalLocation.replace(href);\n            }\n        });\n    };\n    var go = function (n) {\n        globalHistory.go(n);\n    };\n    var goBack = function () { return go(-1); };\n    var goForward = function () { return go(1); };\n    var checkDOMListeners = function (delta) {\n        listenerCount += delta;\n        if (listenerCount === 1) {\n            win.addEventListener(PopStateEvent, handlePopState);\n            if (needsHashChangeListener) {\n                win.addEventListener(HashChangeEvent, handleHashChange);\n            }\n        }\n        else if (listenerCount === 0) {\n            win.removeEventListener(PopStateEvent, handlePopState);\n            if (needsHashChangeListener) {\n                win.removeEventListener(HashChangeEvent, handleHashChange);\n            }\n        }\n    };\n    var block = function (prompt) {\n        if (prompt === void 0) { prompt = ''; }\n        var unblock = transitionManager.setPrompt(prompt);\n        if (!isBlocked) {\n            checkDOMListeners(1);\n            isBlocked = true;\n        }\n        return function () {\n            if (isBlocked) {\n                isBlocked = false;\n                checkDOMListeners(-1);\n            }\n            return unblock();\n        };\n    };\n    var listen = function (listener) {\n        var unlisten = transitionManager.appendListener(listener);\n        checkDOMListeners(1);\n        return function () {\n            checkDOMListeners(-1);\n            unlisten();\n        };\n    };\n    var history = {\n        length: globalHistory.length,\n        action: 'POP',\n        location: initialLocation,\n        createHref: createHref,\n        push: push,\n        replace: replace,\n        go: go,\n        goBack: goBack,\n        goForward: goForward,\n        block: block,\n        listen: listen,\n        win: win\n    };\n    return history;\n};\n// Adapted from the https://github.com/ReactTraining/history and converted to TypeScript\nvar HashChangeEvent$1 = 'hashchange';\nvar HashPathCoders = {\n    hashbang: {\n        encodePath: function (path) { return path.charAt(0) === '!' ? path : '!/' + Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"f\"])(path); },\n        decodePath: function (path) { return path.charAt(0) === '!' ? path.substr(1) : path; }\n    },\n    noslash: {\n        encodePath: _chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"f\"],\n        decodePath: _chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"a\"]\n    },\n    slash: {\n        encodePath: _chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"a\"],\n        decodePath: _chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"a\"]\n    }\n};\nvar createHashHistory = function (win, props) {\n    if (props === void 0) { props = {}; }\n    var forceNextPop = false;\n    var ignorePath = null;\n    var listenerCount = 0;\n    var isBlocked = false;\n    var globalLocation = win.location;\n    var globalHistory = win.history;\n    var canGoWithoutReload = Object(_chunk_4eecdc1a_js__WEBPACK_IMPORTED_MODULE_3__[\"d\"])(win.navigator);\n    var keyLength = (props.keyLength != null) ? props.keyLength : 6;\n    var _a = props.getUserConfirmation, getUserConfirmation = _a === void 0 ? _chunk_4eecdc1a_js__WEBPACK_IMPORTED_MODULE_3__[\"g\"] : _a, _b = props.hashType, hashType = _b === void 0 ? 'slash' : _b;\n    var basename = props.basename ? Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"s\"])(Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"a\"])(props.basename)) : '';\n    var _c = HashPathCoders[hashType], encodePath = _c.encodePath, decodePath = _c.decodePath;\n    var getHashPath = function () {\n        // We can't use window.location.hash here because it's not\n        // consistent across browsers - Firefox will pre-decode it!\n        var href = globalLocation.href;\n        var hashIndex = href.indexOf('#');\n        return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\n    };\n    var pushHashPath = function (path) { return (globalLocation.hash = path); };\n    var replaceHashPath = function (path) {\n        var hashIndex = globalLocation.href.indexOf('#');\n        globalLocation.replace(globalLocation.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);\n    };\n    var getDOMLocation = function () {\n        var path = decodePath(getHashPath());\n        warning((!basename || Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"h\"])(path, basename)), 'You are attempting to use a basename on a page whose URL path does not begin ' +\n            'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\n        if (basename) {\n            path = Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"b\"])(path, basename);\n        }\n        return Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"c\"])(path, undefined, Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"d\"])(keyLength));\n    };\n    var transitionManager = createTransitionManager();\n    var setState = function (nextState) {\n        Object.assign(history, nextState);\n        history.length = globalHistory.length;\n        transitionManager.notifyListeners(history.location, history.action);\n    };\n    var handleHashChange = function () {\n        var path = getHashPath();\n        var encodedPath = encodePath(path);\n        if (path !== encodedPath) {\n            // Ensure we always have a properly-encoded hash.\n            replaceHashPath(encodedPath);\n        }\n        else {\n            var location = getDOMLocation();\n            var prevLocation = history.location;\n            if (!forceNextPop && Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"l\"])(prevLocation, location)) {\n                return; // A hashchange doesn't always == location change.\n            }\n            if (ignorePath === Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"e\"])(location)) {\n                return; // Ignore this change; we already setState in push/replace.\n            }\n            ignorePath = null;\n            handlePop(location);\n        }\n    };\n    var handlePop = function (location) {\n        if (forceNextPop) {\n            forceNextPop = false;\n            setState();\n        }\n        else {\n            var action_2 = 'POP';\n            transitionManager.confirmTransitionTo(location, action_2, getUserConfirmation, function (ok) {\n                if (ok) {\n                    setState({ action: action_2, location: location });\n                }\n                else {\n                    revertPop(location);\n                }\n            });\n        }\n    };\n    var revertPop = function (fromLocation) {\n        var toLocation = history.location;\n        // TODO: We could probably make this more reliable by\n        // keeping a list of paths we've seen in sessionStorage.\n        // Instead, we just default to 0 for paths we don't know.\n        var toIndex = allPaths.lastIndexOf(Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"e\"])(toLocation));\n        var fromIndex = allPaths.lastIndexOf(Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"e\"])(fromLocation));\n        if (toIndex === -1) {\n            toIndex = 0;\n        }\n        if (fromIndex === -1) {\n            fromIndex = 0;\n        }\n        var delta = toIndex - fromIndex;\n        if (delta) {\n            forceNextPop = true;\n            go(delta);\n        }\n    };\n    // Ensure the hash is encoded properly before doing anything else.\n    var path = getHashPath();\n    var encodedPath = encodePath(path);\n    if (path !== encodedPath) {\n        replaceHashPath(encodedPath);\n    }\n    var initialLocation = getDOMLocation();\n    var allPaths = [Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"e\"])(initialLocation)];\n    // Public interface\n    var createHref = function (location) { return ('#' + encodePath(basename + Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"e\"])(location))); };\n    var push = function (path, state) {\n        warning(state === undefined, 'Hash history cannot push state; it is ignored');\n        var action = 'PUSH';\n        var location = Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"c\"])(path, undefined, Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"d\"])(keyLength), history.location);\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n            if (!ok) {\n                return;\n            }\n            var path = Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"e\"])(location);\n            var encodedPath = encodePath(basename + path);\n            var hashChanged = getHashPath() !== encodedPath;\n            if (hashChanged) {\n                // We cannot tell if a hashchange was caused by a PUSH, so we'd\n                // rather setState here and ignore the hashchange. The caveat here\n                // is that other hash histories in the page will consider it a POP.\n                ignorePath = path;\n                pushHashPath(encodedPath);\n                var prevIndex = allPaths.lastIndexOf(Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"e\"])(history.location));\n                var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n                nextPaths.push(path);\n                allPaths = nextPaths;\n                setState({ action: action, location: location });\n            }\n            else {\n                warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');\n                setState();\n            }\n        });\n    };\n    var replace = function (path, state) {\n        warning(state === undefined, 'Hash history cannot replace state; it is ignored');\n        var action = 'REPLACE';\n        var location = Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"c\"])(path, undefined, Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"d\"])(keyLength), history.location);\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n            if (!ok) {\n                return;\n            }\n            var path = Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"e\"])(location);\n            var encodedPath = encodePath(basename + path);\n            var hashChanged = getHashPath() !== encodedPath;\n            if (hashChanged) {\n                // We cannot tell if a hashchange was caused by a REPLACE, so we'd\n                // rather setState here and ignore the hashchange. The caveat here\n                // is that other hash histories in the page will consider it a POP.\n                ignorePath = path;\n                replaceHashPath(encodedPath);\n            }\n            var prevIndex = allPaths.indexOf(Object(_chunk_d2e78d53_js__WEBPACK_IMPORTED_MODULE_2__[\"e\"])(history.location));\n            if (prevIndex !== -1) {\n                allPaths[prevIndex] = path;\n            }\n            setState({ action: action, location: location });\n        });\n    };\n    var go = function (n) {\n        warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');\n        globalHistory.go(n);\n    };\n    var goBack = function () { return go(-1); };\n    var goForward = function () { return go(1); };\n    var checkDOMListeners = function (win, delta) {\n        listenerCount += delta;\n        if (listenerCount === 1) {\n            win.addEventListener(HashChangeEvent$1, handleHashChange);\n        }\n        else if (listenerCount === 0) {\n            win.removeEventListener(HashChangeEvent$1, handleHashChange);\n        }\n    };\n    var block = function (prompt) {\n        if (prompt === void 0) { prompt = ''; }\n        var unblock = transitionManager.setPrompt(prompt);\n        if (!isBlocked) {\n            checkDOMListeners(win, 1);\n            isBlocked = true;\n        }\n        return function () {\n            if (isBlocked) {\n                isBlocked = false;\n                checkDOMListeners(win, -1);\n            }\n            return unblock();\n        };\n    };\n    var listen = function (listener) {\n        var unlisten = transitionManager.appendListener(listener);\n        checkDOMListeners(win, 1);\n        return function () {\n            checkDOMListeners(win, -1);\n            unlisten();\n        };\n    };\n    var history = {\n        length: globalHistory.length,\n        action: 'POP',\n        location: initialLocation,\n        createHref: createHref,\n        push: push,\n        replace: replace,\n        go: go,\n        goBack: goBack,\n        goForward: goForward,\n        block: block,\n        listen: listen,\n        win: win\n    };\n    return history;\n};\nvar getLocation = function (location, root) {\n    // Remove the root URL if found at beginning of string\n    var pathname = location.pathname.indexOf(root) == 0 ?\n        '/' + location.pathname.slice(root.length) :\n        location.pathname;\n    return Object.assign({}, location, { pathname: pathname });\n};\nvar HISTORIES = {\n    'browser': createBrowserHistory,\n    'hash': createHashHistory\n};\n/**\n  * @name Router\n  * @module ionic\n  * @description\n */\nvar Router = /** @class */ (function () {\n    function Router(hostRef) {\n        var _this = this;\n        Object(_stencilrouter_1307249c_js__WEBPACK_IMPORTED_MODULE_0__[\"r\"])(this, hostRef);\n        this.root = '/';\n        this.historyType = 'browser';\n        // A suffix to append to the page title whenever\n        // it's updated through RouteTitle\n        this.titleSuffix = '';\n        this.routeViewsUpdated = function (options) {\n            if (options === void 0) { options = {}; }\n            if (_this.history && options.scrollToId && _this.historyType === 'browser') {\n                var elm = _this.history.win.document.getElementById(options.scrollToId);\n                if (elm) {\n                    return elm.scrollIntoView();\n                }\n            }\n            _this.scrollTo(options.scrollTopOffset || _this.scrollTopOffset);\n        };\n        this.isServer = Object(_stencilrouter_1307249c_js__WEBPACK_IMPORTED_MODULE_0__[\"c\"])(this, \"isServer\");\n        this.queue = Object(_stencilrouter_1307249c_js__WEBPACK_IMPORTED_MODULE_0__[\"c\"])(this, \"queue\");\n    }\n    Router.prototype.componentWillLoad = function () {\n        var _this = this;\n        this.history = HISTORIES[this.historyType](this.el.ownerDocument.defaultView);\n        this.history.listen(function (location) {\n            location = getLocation(location, _this.root);\n            _this.location = location;\n        });\n        this.location = getLocation(this.history.location, this.root);\n    };\n    Router.prototype.scrollTo = function (scrollToLocation) {\n        var history = this.history;\n        if (scrollToLocation == null || this.isServer || !history) {\n            return;\n        }\n        if (history.action === 'POP' && Array.isArray(history.location.scrollPosition)) {\n            return this.queue.write(function () {\n                if (history && history.location && Array.isArray(history.location.scrollPosition)) {\n                    history.win.scrollTo(history.location.scrollPosition[0], history.location.scrollPosition[1]);\n                }\n            });\n        }\n        // okay, the frame has passed. Go ahead and render now\n        return this.queue.write(function () {\n            history.win.scrollTo(0, scrollToLocation);\n        });\n    };\n    Router.prototype.render = function () {\n        if (!this.location || !this.history) {\n            return;\n        }\n        var state = {\n            historyType: this.historyType,\n            location: this.location,\n            titleSuffix: this.titleSuffix,\n            root: this.root,\n            history: this.history,\n            routeViewsUpdated: this.routeViewsUpdated\n        };\n        return (Object(_stencilrouter_1307249c_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(_chunk_cfc6485e_js__WEBPACK_IMPORTED_MODULE_1__[\"A\"].Provider, { state: state }, Object(_stencilrouter_1307249c_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(\"slot\", null)));\n    };\n    Object.defineProperty(Router.prototype, \"el\", {\n        get: function () { return Object(_stencilrouter_1307249c_js__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(this); },\n        enumerable: true,\n        configurable: true\n    });\n    return Router;\n}());\n\n\n\n//# sourceURL=webpack:////__w/gx-web-editors/gx-web-editors/node_modules/@stencil/router/dist/esm/legacy/stencil-router.entry.js?");

/***/ })

}]);