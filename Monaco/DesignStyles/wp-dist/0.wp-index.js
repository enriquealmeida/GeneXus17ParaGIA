(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ "../text-editor/dist/esm-es5/active-router-9e2533ec.js":
/*!*************************************************************!*\
  !*** ../text-editor/dist/esm-es5/active-router-9e2533ec.js ***!
  \*************************************************************/
/*! exports provided: A */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"A\", function() { return ActiveRouter; });\n/* harmony import */ var _index_7f90bc21_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-7f90bc21.js */ \"../text-editor/dist/esm-es5/index-7f90bc21.js\");\nvar __spreadArrays = (undefined && undefined.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\n\nvar createProviderConsumer = function (defaultState, consumerRender) {\n    var listeners = new Map();\n    var currentState = defaultState;\n    var updateListener = function (fields, instance) {\n        if (Array.isArray(fields)) {\n            __spreadArrays(fields).forEach(function (fieldName) {\n                instance[fieldName] = currentState[fieldName];\n            });\n        }\n        else {\n            instance[fields] = Object.assign({}, currentState);\n        }\n    };\n    var subscribe = function (instance, propList) {\n        if (!listeners.has(instance)) {\n            listeners.set(instance, propList);\n            updateListener(propList, instance);\n        }\n        return function () {\n            if (listeners.has(instance)) {\n                listeners.delete(instance);\n            }\n        };\n    };\n    var Provider = function (_a, children) {\n        var state = _a.state;\n        currentState = state;\n        listeners.forEach(updateListener);\n        return children;\n    };\n    var Consumer = function (props, children) {\n        // The casting on subscribe is to allow for crossover through the stencil compiler\n        // In the future we should allow for generics in components.\n        return consumerRender(subscribe, children[0]);\n    };\n    var injectProps = function (Cstr, fieldList) {\n        var CstrPrototype = Cstr.prototype;\n        var cstrConnectedCallback = CstrPrototype.connectedCallback;\n        var cstrDisconnectedCallback = CstrPrototype.disconnectedCallback;\n        CstrPrototype.connectedCallback = function () {\n            subscribe(this, fieldList);\n            if (cstrConnectedCallback) {\n                return cstrConnectedCallback.call(this);\n            }\n        };\n        CstrPrototype.disconnectedCallback = function () {\n            listeners.delete(this);\n            if (cstrDisconnectedCallback) {\n                cstrDisconnectedCallback.call(this);\n            }\n        };\n    };\n    return {\n        Provider: Provider,\n        Consumer: Consumer,\n        injectProps: injectProps\n    };\n};\nvar ActiveRouter = createProviderConsumer({\n    historyType: 'browser',\n    location: {\n        pathname: '',\n        query: {},\n        key: ''\n    },\n    titleSuffix: '',\n    root: '/',\n    routeViewsUpdated: function () { }\n}, function (subscribe, child) { return (Object(_index_7f90bc21_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(\"context-consumer\", { subscribe: subscribe, renderer: child })); });\n\n\n\n//# sourceURL=webpack:///../text-editor/dist/esm-es5/active-router-9e2533ec.js?");

/***/ }),

/***/ "../text-editor/dist/esm-es5/location-utils-aaafd5ed.js":
/*!**************************************************************!*\
  !*** ../text-editor/dist/esm-es5/location-utils-aaafd5ed.js ***!
  \**************************************************************/
/*! exports provided: a, b, c, d, e, f, h, l, s, v */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return addLeadingSlash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return createKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return createLocation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return stripBasename; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return createPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return stripLeadingSlash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return hasBasename; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"l\", function() { return locationsAreEqual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"s\", function() { return stripTrailingSlash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"v\", function() { return valueEqual; });\nvar hasBasename = function (path, prefix) {\n    return (new RegExp('^' + prefix + '(\\\\/|\\\\?|#|$)', 'i')).test(path);\n};\nvar stripBasename = function (path, prefix) {\n    return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\n};\nvar stripTrailingSlash = function (path) {\n    return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;\n};\nvar addLeadingSlash = function (path) {\n    return path.charAt(0) === '/' ? path : '/' + path;\n};\nvar stripLeadingSlash = function (path) {\n    return path.charAt(0) === '/' ? path.substr(1) : path;\n};\nvar parsePath = function (path) {\n    var pathname = path || '/';\n    var search = '';\n    var hash = '';\n    var hashIndex = pathname.indexOf('#');\n    if (hashIndex !== -1) {\n        hash = pathname.substr(hashIndex);\n        pathname = pathname.substr(0, hashIndex);\n    }\n    var searchIndex = pathname.indexOf('?');\n    if (searchIndex !== -1) {\n        search = pathname.substr(searchIndex);\n        pathname = pathname.substr(0, searchIndex);\n    }\n    return {\n        pathname: pathname,\n        search: search === '?' ? '' : search,\n        hash: hash === '#' ? '' : hash,\n        query: {},\n        key: ''\n    };\n};\nvar createPath = function (location) {\n    var pathname = location.pathname, search = location.search, hash = location.hash;\n    var path = pathname || '/';\n    if (search && search !== '?') {\n        path += (search.charAt(0) === '?' ? search : \"?\" + search);\n    }\n    if (hash && hash !== '#') {\n        path += (hash.charAt(0) === '#' ? hash : \"#\" + hash);\n    }\n    return path;\n};\nvar parseQueryString = function (query) {\n    if (!query) {\n        return {};\n    }\n    return (/^[?#]/.test(query) ? query.slice(1) : query)\n        .split('&')\n        .reduce(function (params, param) {\n        var _a = param.split('='), key = _a[0], value = _a[1];\n        params[key] = value ? decodeURIComponent(value.replace(/\\+/g, ' ')) : '';\n        return params;\n    }, {});\n};\nvar isAbsolute = function (pathname) {\n    return pathname.charAt(0) === '/';\n};\nvar createKey = function (keyLength) {\n    return Math.random().toString(36).substr(2, keyLength);\n};\n// About 1.5x faster than the two-arg version of Array#splice()\nvar spliceOne = function (list, index) {\n    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\n        list[i] = list[k];\n    }\n    list.pop();\n};\n// This implementation is based heavily on node's url.parse\nvar resolvePathname = function (to, from) {\n    if (from === void 0) { from = ''; }\n    var fromParts = from && from.split('/') || [];\n    var hasTrailingSlash;\n    var up = 0;\n    var toParts = to && to.split('/') || [];\n    var isToAbs = to && isAbsolute(to);\n    var isFromAbs = from && isAbsolute(from);\n    var mustEndAbs = isToAbs || isFromAbs;\n    if (to && isAbsolute(to)) {\n        // to is absolute\n        fromParts = toParts;\n    }\n    else if (toParts.length) {\n        // to is relative, drop the filename\n        fromParts.pop();\n        fromParts = fromParts.concat(toParts);\n    }\n    if (!fromParts.length) {\n        return '/';\n    }\n    if (fromParts.length) {\n        var last = fromParts[fromParts.length - 1];\n        hasTrailingSlash = (last === '.' || last === '..' || last === '');\n    }\n    else {\n        hasTrailingSlash = false;\n    }\n    for (var i = fromParts.length; i >= 0; i--) {\n        var part = fromParts[i];\n        if (part === '.') {\n            spliceOne(fromParts, i);\n        }\n        else if (part === '..') {\n            spliceOne(fromParts, i);\n            up++;\n        }\n        else if (up) {\n            spliceOne(fromParts, i);\n            up--;\n        }\n    }\n    if (!mustEndAbs) {\n        for (; up--; up) {\n            fromParts.unshift('..');\n        }\n    }\n    if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) {\n        fromParts.unshift('');\n    }\n    var result = fromParts.join('/');\n    if (hasTrailingSlash && result.substr(-1) !== '/') {\n        result += '/';\n    }\n    return result;\n};\nvar valueEqual = function (a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a == null || b == null) {\n        return false;\n    }\n    if (Array.isArray(a)) {\n        return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {\n            return valueEqual(item, b[index]);\n        });\n    }\n    var aType = typeof a;\n    var bType = typeof b;\n    if (aType !== bType) {\n        return false;\n    }\n    if (aType === 'object') {\n        var aValue = a.valueOf();\n        var bValue = b.valueOf();\n        if (aValue !== a || bValue !== b) {\n            return valueEqual(aValue, bValue);\n        }\n        var aKeys = Object.keys(a);\n        var bKeys = Object.keys(b);\n        if (aKeys.length !== bKeys.length) {\n            return false;\n        }\n        return aKeys.every(function (key) {\n            return valueEqual(a[key], b[key]);\n        });\n    }\n    return false;\n};\nvar locationsAreEqual = function (a, b) {\n    return a.pathname === b.pathname &&\n        a.search === b.search &&\n        a.hash === b.hash &&\n        a.key === b.key &&\n        valueEqual(a.state, b.state);\n};\nvar createLocation = function (path, state, key, currentLocation) {\n    var location;\n    if (typeof path === 'string') {\n        // Two-arg form: push(path, state)\n        location = parsePath(path);\n        if (state !== undefined) {\n            location.state = state;\n        }\n    }\n    else {\n        // One-arg form: push(location)\n        location = Object.assign({ pathname: '' }, path);\n        if (location.search && location.search.charAt(0) !== '?') {\n            location.search = '?' + location.search;\n        }\n        if (location.hash && location.hash.charAt(0) !== '#') {\n            location.hash = '#' + location.hash;\n        }\n        if (state !== undefined && location.state === undefined) {\n            location.state = state;\n        }\n    }\n    try {\n        location.pathname = decodeURI(location.pathname);\n    }\n    catch (e) {\n        if (e instanceof URIError) {\n            throw new URIError('Pathname \"' + location.pathname + '\" could not be decoded. ' +\n                'This is likely caused by an invalid percent-encoding.');\n        }\n        else {\n            throw e;\n        }\n    }\n    location.key = key;\n    if (currentLocation) {\n        // Resolve incomplete/relative pathname relative to current location.\n        if (!location.pathname) {\n            location.pathname = currentLocation.pathname;\n        }\n        else if (location.pathname.charAt(0) !== '/') {\n            location.pathname = resolvePathname(location.pathname, currentLocation.pathname);\n        }\n    }\n    else {\n        // When there is no prior location and pathname is empty, set it to /\n        if (!location.pathname) {\n            location.pathname = '/';\n        }\n    }\n    location.query = parseQueryString(location.search || '');\n    return location;\n};\n\n\n\n//# sourceURL=webpack:///../text-editor/dist/esm-es5/location-utils-aaafd5ed.js?");

/***/ }),

/***/ "../text-editor/dist/esm-es5/match-path-42f62261.js":
/*!**********************************************************!*\
  !*** ../text-editor/dist/esm-es5/match-path-42f62261.js ***!
  \**********************************************************/
/*! exports provided: a, m */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return matchesAreEqual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"m\", function() { return matchPath; });\n/* harmony import */ var _location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./location-utils-aaafd5ed.js */ \"../text-editor/dist/esm-es5/location-utils-aaafd5ed.js\");\n\n/**\n * TS adaption of https://github.com/pillarjs/path-to-regexp/blob/master/index.js\n */\n/**\n * Default configs.\n */\nvar DEFAULT_DELIMITER = '/';\nvar DEFAULT_DELIMITERS = './';\n/**\n * The main path matching regexp utility.\n */\nvar PATH_REGEXP = new RegExp([\n    // Match escaped characters that would otherwise appear in future matches.\n    // This allows the user to escape special characters that won't transform.\n    '(\\\\\\\\.)',\n    // Match Express-style parameters and un-named parameters with a prefix\n    // and optional suffixes. Matches appear as:\n    //\n    // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\"]\n    // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined]\n    '(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?'\n].join('|'), 'g');\n/**\n * Parse a string for the raw tokens.\n */\nvar parse = function (str, options) {\n    var tokens = [];\n    var key = 0;\n    var index = 0;\n    var path = '';\n    var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER;\n    var delimiters = (options && options.delimiters) || DEFAULT_DELIMITERS;\n    var pathEscaped = false;\n    var res;\n    while ((res = PATH_REGEXP.exec(str)) !== null) {\n        var m = res[0];\n        var escaped = res[1];\n        var offset = res.index;\n        path += str.slice(index, offset);\n        index = offset + m.length;\n        // Ignore already escaped sequences.\n        if (escaped) {\n            path += escaped[1];\n            pathEscaped = true;\n            continue;\n        }\n        var prev = '';\n        var next = str[index];\n        var name = res[2];\n        var capture = res[3];\n        var group = res[4];\n        var modifier = res[5];\n        if (!pathEscaped && path.length) {\n            var k = path.length - 1;\n            if (delimiters.indexOf(path[k]) > -1) {\n                prev = path[k];\n                path = path.slice(0, k);\n            }\n        }\n        // Push the current path onto the tokens.\n        if (path) {\n            tokens.push(path);\n            path = '';\n            pathEscaped = false;\n        }\n        var partial = prev !== '' && next !== undefined && next !== prev;\n        var repeat = modifier === '+' || modifier === '*';\n        var optional = modifier === '?' || modifier === '*';\n        var delimiter = prev || defaultDelimiter;\n        var pattern = capture || group;\n        tokens.push({\n            name: name || key++,\n            prefix: prev,\n            delimiter: delimiter,\n            optional: optional,\n            repeat: repeat,\n            partial: partial,\n            pattern: pattern ? escapeGroup(pattern) : '[^' + escapeString(delimiter) + ']+?'\n        });\n    }\n    // Push any remaining characters.\n    if (path || index < str.length) {\n        tokens.push(path + str.substr(index));\n    }\n    return tokens;\n};\n/**\n * Escape a regular expression string.\n */\nvar escapeString = function (str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1');\n};\n/**\n * Escape the capturing group by escaping special characters and meaning.\n */\nvar escapeGroup = function (group) {\n    return group.replace(/([=!:$/()])/g, '\\\\$1');\n};\n/**\n * Get the flags for a regexp from the options.\n */\nvar flags = function (options) {\n    return options && options.sensitive ? '' : 'i';\n};\n/**\n * Pull out keys from a regexp.\n */\nvar regexpToRegexp = function (path, keys) {\n    if (!keys)\n        return path;\n    // Use a negative lookahead to match only capturing groups.\n    var groups = path.source.match(/\\((?!\\?)/g);\n    if (groups) {\n        for (var i = 0; i < groups.length; i++) {\n            keys.push({\n                name: i,\n                prefix: null,\n                delimiter: null,\n                optional: false,\n                repeat: false,\n                partial: false,\n                pattern: null\n            });\n        }\n    }\n    return path;\n};\n/**\n * Transform an array into a regexp.\n */\nvar arrayToRegexp = function (path, keys, options) {\n    var parts = [];\n    for (var i = 0; i < path.length; i++) {\n        parts.push(pathToRegexp(path[i], keys, options).source);\n    }\n    return new RegExp('(?:' + parts.join('|') + ')', flags(options));\n};\n/**\n * Create a path regexp from string input.\n */\nvar stringToRegexp = function (path, keys, options) {\n    return tokensToRegExp(parse(path, options), keys, options);\n};\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nvar tokensToRegExp = function (tokens, keys, options) {\n    options = options || {};\n    var strict = options.strict;\n    var end = options.end !== false;\n    var delimiter = escapeString(options.delimiter || DEFAULT_DELIMITER);\n    var delimiters = options.delimiters || DEFAULT_DELIMITERS;\n    var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|');\n    var route = '';\n    var isEndDelimited = false;\n    // Iterate over the tokens and create our regexp string.\n    for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n        if (typeof token === 'string') {\n            route += escapeString(token);\n            isEndDelimited = i === tokens.length - 1 && delimiters.indexOf(token[token.length - 1]) > -1;\n        }\n        else {\n            var prefix = escapeString(token.prefix || '');\n            var capture = token.repeat\n                ? '(?:' + token.pattern + ')(?:' + prefix + '(?:' + token.pattern + '))*'\n                : token.pattern;\n            if (keys)\n                keys.push(token);\n            if (token.optional) {\n                if (token.partial) {\n                    route += prefix + '(' + capture + ')?';\n                }\n                else {\n                    route += '(?:' + prefix + '(' + capture + '))?';\n                }\n            }\n            else {\n                route += prefix + '(' + capture + ')';\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += '(?:' + delimiter + ')?';\n        route += endsWith === '$' ? '$' : '(?=' + endsWith + ')';\n    }\n    else {\n        if (!strict)\n            route += '(?:' + delimiter + '(?=' + endsWith + '))?';\n        if (!isEndDelimited)\n            route += '(?=' + delimiter + '|' + endsWith + ')';\n    }\n    return new RegExp('^' + route, flags(options));\n};\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nvar pathToRegexp = function (path, keys, options) {\n    if (path instanceof RegExp) {\n        return regexpToRegexp(path, keys);\n    }\n    if (Array.isArray(path)) {\n        return arrayToRegexp(path, keys, options);\n    }\n    return stringToRegexp(path, keys, options);\n};\nvar cacheCount = 0;\nvar patternCache = {};\nvar cacheLimit = 10000;\n// Memoized function for creating the path match regex\nvar compilePath = function (pattern, options) {\n    var cacheKey = \"\" + options.end + options.strict;\n    var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\n    var cachePattern = JSON.stringify(pattern);\n    if (cache[cachePattern]) {\n        return cache[cachePattern];\n    }\n    var keys = [];\n    var re = pathToRegexp(pattern, keys, options);\n    var compiledPattern = { re: re, keys: keys };\n    if (cacheCount < cacheLimit) {\n        cache[cachePattern] = compiledPattern;\n        cacheCount += 1;\n    }\n    return compiledPattern;\n};\n/**\n * Public API for matching a URL pathname to a path pattern.\n */\nvar matchPath = function (pathname, options) {\n    if (options === void 0) { options = {}; }\n    if (typeof options === 'string') {\n        options = { path: options };\n    }\n    var _a = options.path, path = _a === void 0 ? '/' : _a, _b = options.exact, exact = _b === void 0 ? false : _b, _c = options.strict, strict = _c === void 0 ? false : _c;\n    var _d = compilePath(path, { end: exact, strict: strict }), re = _d.re, keys = _d.keys;\n    var match = re.exec(pathname);\n    if (!match) {\n        return null;\n    }\n    var url = match[0], values = match.slice(1);\n    var isExact = pathname === url;\n    if (exact && !isExact) {\n        return null;\n    }\n    return {\n        path: path,\n        url: path === '/' && url === '' ? '/' : url,\n        isExact: isExact,\n        params: keys.reduce(function (memo, key, index) {\n            memo[key.name] = values[index];\n            return memo;\n        }, {})\n    };\n};\nvar matchesAreEqual = function (a, b) {\n    if (a == null && b == null) {\n        return true;\n    }\n    if (b == null) {\n        return false;\n    }\n    return a && b &&\n        a.path === b.path &&\n        a.url === b.url &&\n        Object(_location_utils_aaafd5ed_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(a.params, b.params);\n};\n\n\n\n//# sourceURL=webpack:///../text-editor/dist/esm-es5/match-path-42f62261.js?");

/***/ })

}]);